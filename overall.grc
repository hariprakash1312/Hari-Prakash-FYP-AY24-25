options:
  parameters:
    author: lowai
    catch_exceptions: 'True'
    category: '[GRC Hier Blocks]'
    cmake_opt: ''
    comment: ''
    copyright: ''
    description: ''
    gen_cmake: 'On'
    gen_linking: dynamic
    generate_options: qt_gui
    hier_block_src_path: '.:'
    id: overall
    max_nouts: '0'
    output_language: python
    placement: (0,0)
    qt_qss_theme: ''
    realtime_scheduling: ''
    run: 'True'
    run_command: '{python} -u {filename}'
    run_options: prompt
    sizing_mode: fixed
    thread_safe_setters: ''
    title: Not titled yet
    window_size: (1000,1000)
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [8, 8]
    rotation: 0
    state: enabled

blocks:
- name: bpsk
  id: variable_constellation
  parameters:
    comment: ''
    const_points: '[-1-1j, -1+1j, 1+1j, 1-1j]'
    dims: '1'
    normalization: digital.constellation.AMPLITUDE_NORMALIZATION
    npwr: '1.0'
    precision: '8'
    rot_sym: '4'
    soft_dec_lut: None
    sym_map: '[0, 1, 3, 2]'
    type: bpsk
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [8, 148.0]
    rotation: 0
    state: enabled
- name: delay
  id: variable_qtgui_range
  parameters:
    comment: ''
    gui_hint: ''
    label: delay
    min_len: '200'
    orient: QtCore.Qt.Horizontal
    rangeType: int
    start: '0'
    step: '1'
    stop: '500'
    value: '149'
    widget: counter_slider
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [2088, 72.0]
    rotation: 0
    state: disabled
- name: nfilts
  id: variable
  parameters:
    comment: ''
    value: '25'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [464, 16.0]
    rotation: 0
    state: enabled
- name: packet_len
  id: variable_tag_object
  parameters:
    comment: ''
    key: pmt.intern("packet_len")
    offset: '0'
    src: pmt.intern("src")
    value: pmt.from_long(5)
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [736, 44.0]
    rotation: 0
    state: enabled
- name: push_button
  id: variable_qtgui_push_button
  parameters:
    comment: ''
    gui_hint: ''
    label: push_start
    pressed: '1'
    released: '0'
    type: int
    value: '0'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [2848, 684.0]
    rotation: 0
    state: enabled
- name: rrc_taps
  id: variable
  parameters:
    comment: ''
    value: firdes.root_raised_cosine(nfilts, nfilts, 1.0/float(sps), 0.35, 45*nfilts)
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [240, 16.0]
    rotation: 0
    state: enabled
- name: samp_rate
  id: variable
  parameters:
    comment: ''
    value: '2084000'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [344, 120.0]
    rotation: 0
    state: enabled
- name: sps
  id: variable
  parameters:
    comment: ''
    value: '4'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [248, 120.0]
    rotation: 0
    state: enabled
- name: AbstractFopState
  id: epy_module
  parameters:
    alias: ''
    comment: ''
    source_code: "from abc import ABC, abstractmethod\r\nfrom overall_FopAlertCode\
      \ import FopAlertCode\r\n\r\n# Define the actions to perform and appropriate\
      \ methods to call for some FOP-1 events applicable to all FOP-1 states \r\n\
      class AbstractFopState(ABC):\r\n    def __init__(self, engine):\r\n        self.engine\
      \ = engine\r\n        self.event2handler = {\r\n        }\r\n        self.register_handlers()\r\
      \n\r\n    @abstractmethod\r\n    # Registering event handlers for different\
      \ FOP events\r\n    def register_handlers(self):\r\n        # Implementation\
      \ for register_handlers\r\n        pass\r\n\r\n    # Call the handler function\
      \ for a particular event\r\n    def event(self, fop_event):\r\n        handler\
      \ = self.event2handler.get(fop_event.get_number()) # Get the handler function\r\
      \n        if handler:\r\n            return handler(fop_event) # Call the handler\
      \ function, which will return the next FOP state\r\n        else:\r\n      \
      \      return self\r\n\r\n    @abstractmethod\r\n    # Return the current state\r\
      \n    def get_state(self):\r\n        # Implementation for getState\r\n    \
      \    pass\r\n\r\n    # Reject the fop event\r\n    def reject(self, fop_event):\r\
      \n        self.engine.reject_event(fop_event)\r\n        return self\r\n\r\n\
      \    # Ignore the fop event\r\n    def ignore(self, fop_event):\r\n        return\
      \ self\r\n\r\n    # Handler functions for different events\r\n    def e21(self,\
      \ fop_event):\r\n        self.engine.accept(fop_event.get_frame())\r\n     \
      \   self.engine.transmit_type_bd_frame(fop_event.get_frame())\r\n        return\
      \ self\r\n\r\n    def e29(self, fop_event):\r\n        self.engine.accept_directive(fop_event.get_directive_tag(),\
      \ fop_event.get_directive_id(), fop_event.get_directive_qualifier())\r\n   \
      \     self.engine.alert(FopAlertCode.TERM)\r\n        self.engine.confirm_directive(fop_event.get_directive_tag(),\
      \ fop_event.get_directive_id(), fop_event.get_directive_qualifier())\r\n   \
      \     from overall_S6FopState import S6FopState\r\n        return S6FopState(self.engine)\r\
      \n\r\n    def e36(self, fop_event):\r\n        self.engine.accept_directive(fop_event.get_directive_tag(),\
      \ fop_event.get_directive_id(), fop_event.get_directive_qualifier())\r\n   \
      \     self.engine.set_fop_sliding_window(fop_event.get_directive_qualifier())\r\
      \n        self.engine.confirm_directive(fop_event.get_directive_tag(), fop_event.get_directive_id(),\
      \ fop_event.get_directive_qualifier())\r\n        return self\r\n\r\n    def\
      \ e37(self, fop_event):\r\n        self.engine.accept_directive(fop_event.get_directive_tag(),\
      \ fop_event.get_directive_id(), fop_event.get_directive_qualifier())\r\n   \
      \     self.engine.set_t1_initial(fop_event.get_directive_qualifier())\r\n  \
      \      self.engine.confirm_directive(fop_event.get_directive_tag(), fop_event.get_directive_id(),\
      \ fop_event.get_directive_qualifier())\r\n        return self\r\n\r\n    def\
      \ e38(self, fop_event):\r\n        self.engine.accept_directive(fop_event.get_directive_tag(),\
      \ fop_event.get_directive_id(), fop_event.get_directive_qualifier())\r\n   \
      \     self.engine.set_transmission_limit(fop_event.get_directive_qualifier())\r\
      \n        self.engine.confirm_directive(fop_event.get_directive_tag(), fop_event.get_directive_id(),\
      \ fop_event.get_directive_qualifier())\r\n        return self\r\n\r\n    def\
      \ e39(self, fop_event):\r\n        self.engine.accept_directive(fop_event.get_directive_tag(),\
      \ fop_event.get_directive_id(), fop_event.get_directive_qualifier())\r\n   \
      \     self.engine.set_timeout_type(fop_event.get_directive_qualifier())\r\n\
      \        self.engine.confirm_directive(fop_event.get_directive_tag(), fop_event.get_directive_id(),\
      \ fop_event.get_directive_qualifier())\r\n        return self\r\n\r\n    def\
      \ e42(self, fop_event):\r\n        self.engine.alert(FopAlertCode.LLIF)\r\n\
      \        from overall_S6FopState import S6FopState\r\n        return S6FopState(self.engine)\r\
      \n\r\n    def e44(self, fop_event):\r\n        self.engine.alert(FopAlertCode.LLIF)\r\
      \n        from overall_S6FopState import S6FopState\r\n        return S6FopState(self.engine)\r\
      \n\r\n    def e45(self, fop_event):\r\n        self.engine.set_bd_out_ready_flag(True)\r\
      \n        return self\r\n\r\n    def e46(self, fop_event):\r\n        self.engine.alert(FopAlertCode.LLIF)\r\
      \n        from overall_S6FopState import S6FopState\r\n        return S6FopState(self.engine)\r\
      \n\r\n\r\n"
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [512, 284.0]
    rotation: 0
    state: enabled
- name: BcFrameCollector
  id: epy_module
  parameters:
    alias: ''
    comment: ''
    source_code: "from typing import Optional\r\nfrom overall_TcSenderVirtualChannel\
      \ import TcSenderVirtualChannel\r\nfrom overall_TcTransferFrame import TcTransferFrame\r\
      \n\r\n# Store BC frames, where the TcSenderVirtualChannel will put in BC frames\
      \ created and FopEngine will retrieve BC frames\r\nclass BcFrameCollector:\r\
      \n    def __init__(self, virtual_channel: TcSenderVirtualChannel):\r\n     \
      \   self.virtual_channel = virtual_channel\r\n        self.virtual_channel.register(self)\r\
      \n        self.filter_predicate = TcTransferFrame.FrameType.BC\r\n        self.frame_list\
      \ = []\r\n\r\n    # Return a BC Set V(R) transfer frame\r\n    def apply(self,\
      \ set_vr: int, tag: int) -> Optional[TcTransferFrame]:\r\n        self.retrieve()\
      \ # Clear current list of frames\r\n        self.virtual_channel.dispatch_set_vr(set_vr,tag)\
      \ # Ask virtual channel to make a BC frame for set v(r), which will be stored\
      \ in frame_list\r\n        return self.retrieve_first(True) # Retrieve and return\
      \ the BC frame from frame_list\r\n\r\n    # Return a BC Unlock transfer frame\r\
      \n    def get(self, tag: int) -> Optional[TcTransferFrame]:\r\n        self.retrieve()\
      \ # Clear current list of frames\r\n        self.virtual_channel.dispatch_unlock(tag)\
      \ # Ask virtual channel to make a BC frame for unlock, which will be stored\
      \ in frame_list\r\n        return self.retrieve_first(True) # Retrieve and return\
      \ the BC frame from frame_list\r\n\r\n    # Return and remove first frame from\
      \ frame_list (if exists), clear list if clear_list = True\r\n    def retrieve_first(self,\
      \ clear_list=True):\r\n        first_frame = self.frame_list.pop(0) if self.frame_list\
      \ else None\r\n        if clear_list:\r\n            self.frame_list.clear()\r\
      \n        return first_frame\r\n\r\n    # Return a copy of the current frame_list\
      \ and clears frame_list\r\n    def retrieve(self):\r\n        copied_list =\
      \ self.frame_list.copy()\r\n        self.frame_list.clear()\r\n        return\
      \ copied_list\r\n\r\n    # Add generated_frame to frame_list if it is a BC frame\r\
      \n    def transfer_frame_generated(self, virtual_channel, generated_frame, buffered_bytes):\r\
      \n        if (self.filter_predicate == generated_frame.get_frame_type()):\r\n\
      \            self.frame_list.append(generated_frame)\r\n\r\n"
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [304, 284.0]
    rotation: 0
    state: true
- name: Clcw
  id: epy_module
  parameters:
    alias: ''
    comment: ''
    source_code: "from enum import Enum\r\n\r\nclass Clcw:\r\n    class CopEffectType(Enum):\r\
      \n        NONE = 0\r\n        COP1 = 1\r\n        RESERVED2 = 2\r\n        RESERVED3\
      \ = 3\r\n        \r\n    def __init__(self, ocf):\r\n        if ocf is None\
      \ or len(ocf) == 0:\r\n            raise ValueError(\"OCF array is None or has\
      \ size 0\")\r\n\r\n        self.ocf = ocf # operational control field i.e. clcw\
      \ data\r\n        # Check control word type field of clcw (always 0)\r\n   \
      \     self.clcw = (ocf[0] & 0x80) == 0 \r\n        if not self.clcw:\r\n   \
      \         raise ValueError(\"CLCW Type: expected 0, actual 1\")\r\n\r\n    \
      \    # Check version number field (00)\r\n        self.version_number = (ocf[0]\
      \ & 0x60) >> 5 # Check version number\r\n        if self.version_number != 0:\r\
      \n            raise ValueError(\"CLCW Version Number: expected 0, actual \"\
      \ + str(self.version_number))\r\n\r\n        # clcw fields\r\n        self.status_field\
      \ = (ocf[0] & 0x1C) >> 2\r\n\r\n        cop_in_effect_flag = ocf[0] & 0x03\r\
      \n        self.cop_in_effect = self.CopEffectType(cop_in_effect_flag)\r\n\r\n\
      \        self.virtual_channel_id = (ocf[1] & 0xFC) >> 2\r\n        self.reserved_spare\
      \ = ocf[1] & 0x03\r\n\r\n        self.no_rf_available_flag = (ocf[2] & 0x80)\
      \ != 0\r\n        self.no_bitlock_flag = (ocf[2] & 0x40) != 0\r\n        self.lockout_flag\
      \ = (ocf[2] & 0x20) != 0\r\n        self.wait_flag = (ocf[2] & 0x10) != 0\r\n\
      \        self.retransmit_flag = (ocf[2] & 0x08) != 0\r\n\r\n        self.farm_b_counter\
      \ = (ocf[2] & 0x06) >> 1\r\n        self.report_value = ocf[3]\r\n\r\n    #\
      \ Return version number\r\n    def get_version_number(self):\r\n        return\
      \ self.version_number\r\n\r\n    # Return status field\r\n    def get_status_field(self):\r\
      \n        return self.status_field\r\n\r\n    # Return cop in effect\r\n   \
      \ def get_cop_in_effect(self):\r\n        return self.cop_in_effect\r\n\r\n\
      \    # Return virtual channel id\r\n    def get_virtual_channel_id(self):\r\n\
      \        return self.virtual_channel_id\r\n\r\n    # Return no rf available\
      \ flag\r\n    def is_no_rf_available_flag(self):\r\n        return self.no_rf_available_flag\r\
      \n\r\n    # Return no bitlock flag\r\n    def is_no_bitlock_flag(self):\r\n\
      \        return self.no_bitlock_flag\r\n\r\n    # Return lockout flag\r\n  \
      \  def is_lockout_flag(self):\r\n        return self.lockout_flag\r\n\r\n  \
      \  # Return wait flag\r\n    def is_wait_flag(self):\r\n        return self.wait_flag\r\
      \n\r\n    # Return retransmit flag\r\n    def is_retransmit_flag(self):\r\n\
      \        return self.retransmit_flag\r\n\r\n    # Return farm b counter\r\n\
      \    def get_farm_b_counter(self):\r\n        return self.farm_b_counter\r\n\
      \r\n    # Return report value\r\n    def get_report_value(self):\r\n       \
      \ return self.report_value\r\n\r\n    # Return reserved spare\r\n    def get_reserved_spare(self):\r\
      \n        return self.reserved_spare\r\n\r\n    def __str__(self):\r\n     \
      \   return \"Clcw{\" + \\\r\n               \"versionNumber=\" + str(self.version_number)\
      \ + \\\r\n               \", statusField=\" + str(self.status_field) + \\\r\n\
      \               \", copInEffect=\" + str(self.cop_in_effect) + \\\r\n      \
      \         \", virtualChannelId=\" + str(self.virtual_channel_id) + \\\r\n  \
      \             \", reservedSpare=\" + str(self.reserved_spare) + \\\r\n     \
      \          \", noRfAvailableFlag=\" + str(self.no_rf_available_flag) + \\\r\n\
      \               \", noBitlockFlag=\" + str(self.no_bitlock_flag) + \\\r\n  \
      \             \", lockoutFlag=\" + str(self.lockout_flag) + \\\r\n         \
      \      \", waitFlag=\" + str(self.wait_flag) + \\\r\n               \", retransmitFlag=\"\
      \ + str(self.retransmit_flag) + \\\r\n               \", farmBCounter=\" + str(self.farm_b_counter)\
      \ + \\\r\n               \", reportValue=\" + str(self.report_value) + \\\r\n\
      \               '}'\r\n\r\n    # Return clcw \r\n    def get_ocf(self):\r\n\
      \        return self.ocf\r\n\r\n    # Return whether it is a clcw\r\n    def\
      \ is_clcw(self):\r\n        return self.clcw"
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [304, 476.0]
    rotation: 0
    state: enabled
- name: FopAlertCode
  id: epy_module
  parameters:
    alias: ''
    comment: ''
    source_code: "from enum import Enum\r\n\r\n# Enumerate fop alert codes\r\nclass\
      \ FopAlertCode(Enum):\r\n    LIMIT = 1\r\n    T1 = 2\r\n    LOCKOUT = 3\r\n\
      \    SYNCH = 4\r\n    NN_R = 5\r\n    CLCW = 6\r\n    LLIF = 7\r\n    TERM =\
      \ 8\r\n"
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [64, 284.0]
    rotation: 0
    state: enabled
- name: FopDirective
  id: epy_module
  parameters:
    alias: ''
    comment: ''
    source_code: "from enum import Enum\r\n\r\n# Enumerate fop directives\r\nclass\
      \ FopDirective(Enum):\r\n    INIT_AD_WITHOUT_CLCW = 1\r\n    INIT_AD_WITH_CLCW\
      \ = 2\r\n    INIT_AD_WITH_UNLOCK = 3\r\n    INIT_AD_WITH_SET_V_R = 4\r\n   \
      \ TERMINATE = 5\r\n    RESUME = 6\r\n    SET_V_S = 7\r\n    SET_FOP_SLIDING_WINDOW\
      \ = 8\r\n    SET_T1_INITIAL = 9\r\n    SET_TRANSMISSION_LIMIT = 10\r\n    SET_TIMEOUT_TYPE\
      \ = 11\r\n"
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [64, 348.0]
    rotation: 0
    state: enabled
- name: FopEngine
  id: epy_module
  parameters:
    alias: ''
    comment: ''
    source_code: "\r\nfrom typing import Callable, List\r\nimport threading\r\nfrom\
      \ threading import Thread, Timer\r\nfrom concurrent.futures import ThreadPoolExecutor,\
      \ TimeoutError\r\nimport time\r\n\r\nfrom overall_FopOperationStatus import\
      \ FopOperationStatus\r\nfrom overall_IFopObserver import IFopObserver\r\nfrom\
      \ overall_TcTransferFrame import TcTransferFrame\r\nfrom overall_Clcw import\
      \ Clcw\r\nfrom overall_FopDirective import FopDirective\r\nfrom overall_S6FopState\
      \ import S6FopState\r\nfrom overall_FopEvent import FopEvent\r\nfrom overall_FopStatus\
      \ import FopStatus\r\n\r\n# Multi-thread increment, decrement, get value of\
      \ a shared integer\r\nclass AtomicReference:\r\n    def __init__(self, initial_value=None):\r\
      \n        self._value = initial_value\r\n        self._lock = threading.Lock()\r\
      \n        self._condition = threading.Condition(self._lock)\r\n\r\n    def get(self):\r\
      \n        with self._lock:\r\n            return self._value\r\n\r\n    def\
      \ set(self, new_value):\r\n        with self._lock:\r\n            self._value\
      \ = new_value\r\n            self._condition.notify_all()\r\n            \r\n\
      \    def get_and_set(self, new_value):\r\n        with self._lock:\r\n     \
      \       old_value = self._value\r\n            self._value = new_value\r\n \
      \           return old_value\r\n        \r\n    def notify_all(self):\r\n  \
      \      with self._lock:\r\n            self._condition.notify_all()\r\n    \r\
      \n\r\n# Contains most of the methods that define the logic and actions to be\
      \ taken upon receiving input directives/transfer request/ CLCW\r\nclass FopEngine:\r\
      \n\r\n    def __init__(self,\r\n                 virtual_channel_id: int,\r\n\
      \                 next_virtual_channel_frame_counter_getter: Callable[[], int],\r\
      \n                 next_virtual_channel_frame_counter_setter: Callable[[int],\
      \ None],\r\n                 bc_frame_unlock_factory: Callable[[int], TcTransferFrame],\r\
      \n                 bc_frame_set_vr_factory: Callable[[int,int], TcTransferFrame],\r\
      \n                 output: Callable[[TcTransferFrame], bool],\r\n          \
      \       timer_initial_value,\r\n                 transmission_limit,\r\n   \
      \              timeout_type,\r\n                 fop_sliding_window):\r\n\r\n\
      \        self.virtual_channel_id = virtual_channel_id\r\n        # Function\
      \ to obtain the Transmitter_Frame_Sequence_Number (V(S))\r\n        self.next_virtual_channel_frame_counter_getter\
      \ = next_virtual_channel_frame_counter_getter  \r\n        # Function to set\
      \ the Transmitter_Frame_Sequence_Number (V(S))\r\n        self.next_virtual_channel_frame_counter_setter\
      \ = next_virtual_channel_frame_counter_setter\r\n        # Function to obtain\
      \ a BC unlock frame\r\n        self.bc_frame_unlock_factory = bc_frame_unlock_factory\
      \ \r\n        # Function to obtain a BC set V(R) frame\r\n        self.bc_frame_set_vr_factory\
      \ = bc_frame_set_vr_factory \r\n        # Executor for handling FOP entity processing\
      \ tasks with a single worker thread\r\n        self.fop_executor = ThreadPoolExecutor(max_workers=1,\
      \ thread_name_prefix=f\"FOP Entity Processor for TC VC {virtual_channel_id}\"\
      )\r\n        # Executor for handling low-level FOP tasks with a single worker\
      \ thread\r\n        self.low_level_executor = ThreadPoolExecutor(max_workers=1,\
      \ thread_name_prefix=f\"FOP Entity Low Level for TC VC {virtual_channel_id}\"\
      )\r\n        self.confinement_thread = threading.current_thread()\r\n      \
      \  # List of observers for FOP responses/alerts\r\n        self.observers: List[IFopObserver]\
      \ = []\r\n        # Atomic references for managing pending actions and results\r\
      \n        self.pending_accept_reject_result = AtomicReference() # Result of\
      \ a pending accept/reject operation\r\n        self.pending_accept_reject_frame\
      \ = AtomicReference() # Frame associated with a pending accept/reject operation\r\
      \n        self.pending_event_result = AtomicReference() # Result of a pending\
      \ event\r\n        self.pending_init_ad = AtomicReference() # Pending AD initialization\r\
      \n        self.wait_queue = AtomicReference(None) # Queue for holding FDUs waiting\
      \ for acceptance\r\n\r\n        # Function to forward transfer frames as output\
      \ of Fop Engine\r\n        self.output = output\r\n        self.output_lock\
      \ = threading.Lock()\r\n\r\n        # Timer for transmit timeout\r\n       \
      \ self.current_timer: Optional[Timer] = None\r\n        self.fop_timer_lock\
      \ = threading.Lock()\r\n\r\n        # FOP Variables\r\n        \r\n        #\
      \ When Type-AD FDUs are received from the Higher Procedures, they shall be held\
      \ in the Wait_Queue until they can be accepted \r\n        # by FOP-1. The Wait_Queue\
      \ has a maximum capacity of one FDU. The Wait_Queue and 'Accept Response to\
      \ Request to Transfer FDU' \r\n        # form the primary mechanism by which\
      \ flow control as seen by the Higher Procedures is governed. When an FDU is\
      \ on the Wait_Queue,\r\n        # this means that the Higher Procedures have\
      \ not yet received an 'Accept Response' for the corresponding 'Request to Transfer\
      \ FDU'.\r\n\r\n        # # Flag indicating whether a 'Transmit Request for Frame'\
      \ can be sent for AD frames\r\n        self.ad_out_ready_flag = True\r\n   \
      \     # Flag indicating whether a 'Transmit Request for Frame' can be sent for\
      \ BD frames\r\n        self.bd_out_ready_flag = True\r\n        # Flag indicating\
      \ whether a 'Transmit Request for Frame' can be sent for BC frames\r\n     \
      \   self.bc_out_ready_flag = True\r\n        # Queue for holding all Type-AD\
      \ and Type-BC Transfer Frames between the time a copy of the Transfer Frame\
      \ is first \r\n        # passed to the Lower Procedures for transmission, and\
      \ the time the FOP-1 has finished processing the Transfer Frame.\r\n       \
      \ self.sent_queue: List[self.TransferFrameStatus] = []\r\n        # The expected_ack_frame_sequence_number,\
      \ NN(R), contains the Frame Sequence Number of the oldest unacknowledged AD\
      \ Frame, \r\n        # which is on the Sent_Queue. This value is often equal\
      \ to the value of N(R) from the previous CLCW on that Virtual Channel.\r\n \
      \       self.expected_ack_frame_sequence_number = 0 #NN(R)\r\n        # Whenever\
      \ a Type-AD or Type-BC Transfer Frame is transmitted, the Timer shall be started\r\
      \n        # or restarted with an initial value of Timer_Initial_Value (T1_Initial).\r\
      \n        self.timer_initial_value = timer_initial_value\r\n        # The Transmission_Limit\
      \ holds a value which represents the maximum number of times the first Transfer\
      \ Frame on the Sent_Queue \r\n        # may be transmitted. This includes the\
      \ first 'transmission' and any subsequent 'retransmissions' of the Transfer\
      \ Frame.\r\n        self.transmission_limit = transmission_limit\r\n       \
      \ # The Timeout_Type variable may take one of two values, '0' or '1'. It specifies\
      \ the action to be performed when both the Timer \r\n        # expires and the\
      \ Transmission_Count has reached the Transmission_Limit.\r\n        self.timeout_type\
      \ = timeout_type  #TT\r\n        # The Transmission_Count variable is used to\
      \ count the number of transmissions of the first Transfer Frame on the Sent_Queue.\
      \ \r\n        # The Transmission_Count shall be incremented each time the first\
      \ Transfer Frame is retransmitted.\r\n        self.transmission_count = 0\r\n\
      \        # The Suspend_State variable may take one of five values, from '0'\
      \ to '4'. It records the state that FOP-1 was in when the AD Service was suspended.\
      \ \r\n        # This is the state to which FOP-1 will return should the AD Service\
      \ be resumed. If SS = 0, the AD Service is deemed not suspended.\r\n       \
      \ self.suspend_state = 0  #SS\r\n        # The FOP Sliding Window is a mechanism\
      \ which limits the number of Transfer Frames which can be transmitted ahead\
      \ of the last acknowledged Transfer Frame, \r\n        # i.e., before a CLCW\
      \ report is received which updates the status of acknowledged Transfer Frames.\
      \ This is done\r\n        # to prevent sending a new Transfer Frame with the\
      \ same sequence number as a rejected Transfer Frame.\r\n        self.fop_sliding_window\
      \ = fop_sliding_window  #K\r\n        # State of FOP-1 for the specific Virtual\
      \ Channel\r\n        self.state = S6FopState(self)   \r\n\r\n    # Return the\
      \ TC virtual channel ID\r\n    def get_virtual_channel_id(self) -> int:\r\n\
      \        return self.virtual_channel_id\r\n\r\n    # Register an IFopObserver\
      \ as listener to FOP state changes, alerts and suspends notifications, as well\
      \ as transfer frame and directive notifications\r\n    def register(self, observer)\
      \ -> None:\r\n        self.observers.append(observer)\r\n\r\n    # Deregister\
      \ an IFopObserver listener\r\n    def deregister(self, observer) -> None:\r\n\
      \        self.observers.remove(observer)\r\n\r\n\r\n# ---------------------------------------------------------------------------------------------------------\r\
      \n# FOP-1 public operations as per CCSDS definition for event injection\r\n\
      # ---------------------------------------------------------------------------------------------------------\r\
      \n\r\n    # Request the FOP engine to execute a COP-1 directive.\r\n    # param\
      \ tag: the request tag, which will be returned in the callback on the IFopObserver\
      \ interface\r\n    # param directive: the directive ID\r\n    # param qualifier:\
      \ the directive qualifier: if not meaningful, this argument can assume any value\r\
      \n    def directive(self, tag, directive, qualifier) -> None:\r\n        self.fop_executor.submit(lambda:\
      \ self.process_directive(tag, directive, qualifier))\r\n\r\n    # Request the\
      \ FOP engine to transmit a AD or BD frame\r\n    # param frame: the frame to\
      \ transmit\r\n    # param timeout_millis: the timeout in milliseconds waiting\
      \ for acceptance or rejection of the request\r\n    # return true if the request\
      \ was accepted, false it is was rejected or the timeout expired\r\n    def transmit(self,\
      \ frame, timeout_millis) -> bool:\r\n        expiration_time = timeout_millis\
      \ / 1000.0\r\n        if frame.get_frame_type() == TcTransferFrame.FrameType.BD:\r\
      \n            response = self.transmit_sync_bd(frame, expiration_time)\r\n \
      \           return response\r\n        elif frame.get_frame_type() == TcTransferFrame.FrameType.AD:\r\
      \n            response = self.transmit_sync_ad(frame, expiration_time)\r\n \
      \           return response\r\n        else:\r\n            raise ValueError(\"\
      This method can be invoked only for BD and AD frames\")\r\n\r\n    # BD frames\
      \ can be unblocked as soon as a REJECT_RESPONSE is received (event E22), or\
      \ events E45 or E46 are received.\r\n    # param frame: the frame to send\r\n\
      \    # param expiration_time: the timeout in seconds waiting for acceptance\
      \ or rejection of the request\r\n    # return true if the request was accepted,\
      \ false it is was rejected or the timeout expired           \r\n    def transmit_sync_bd(self,\
      \ frame, expiration_time) -> bool:\r\n        self.pending_accept_reject_frame.set(frame)\r\
      \n        self.pending_event_result.set(None)\r\n        self.transmit_type(frame)\
      \ # Request to transmit frame\r\n        start_time = time.time()\r\n      \
      \  while True:\r\n            if self.pending_event_result.get() is not None:\
      \ # Request accepted/rejected\r\n                operation_result = self.pending_event_result.get_and_set(None)\r\
      \n                self.pending_accept_reject_frame.set(None)\r\n           \
      \     return operation_result == FopEvent.EventNumber.E45\r\n\r\n          \
      \  elapsed_time = time.time() - start_time\r\n            if elapsed_time >=\
      \ expiration_time: # Timeout expired while waiting for acceptance/rejection\
      \ of request\r\n                break\r\n            time.sleep(0.1) \r\n  \
      \      return False\r\n\r\n    # AD frames can be unblocked as soon as an ACCEPT_RESPONSE\
      \ or REJECT_RESPONSE is received.\r\n    # param frame: the frame to send\r\n\
      \    # param expiration_time: the timeout in seconds waiting for acceptance\
      \ or rejection of the request\r\n    # return true if the request was accepted,\
      \ false it is was rejected or the timeout expired        \r\n    def transmit_sync_ad(self,\
      \ frame, expiration_time) -> bool:\r\n        self.pending_accept_reject_frame.set(frame)\r\
      \n        self.pending_accept_reject_result.set(None)\r\n        self.transmit_type(frame)\
      \ # Request to transmit frame\r\n        start_time = time.time()\r\n      \
      \  while True:\r\n            if self.pending_accept_reject_result.get() is\
      \ not None: # Request accepted/rejected\r\n                operation_result\
      \ = self.pending_accept_reject_result.get_and_set(None)\r\n                self.pending_accept_reject_frame.set(None)\r\
      \n                return operation_result == FopOperationStatus.ACCEPT_RESPONSE\r\
      \n\r\n            elapsed_time = time.time() - start_time\r\n            if\
      \ elapsed_time >= expiration_time: # Timeout expired while waiting for acceptance/rejection\
      \ of request\r\n                print(\"fop sliding window full, tc frame in\
      \ wait queue\")\r\n                break\r\n            time.sleep(0.1) \r\n\
      \        return False\r\n\r\n    # Transmit a AD or BD frame\r\n    # param\
      \ frame: the frame to transmit\r\n    def transmit_type(self, frame):\r\n  \
      \      if frame.get_frame_type() == TcTransferFrame.FrameType.BD:\r\n      \
      \      self.process_bd_frame(frame)\r\n        elif frame.get_frame_type() ==\
      \ TcTransferFrame.FrameType.AD:\r\n            self.process_ad_frame(frame)\r\
      \n        else:\r\n            raise ValueError(f\"This method can be invoked\
      \ only for BD and AD frames\")\r\n\r\n    # Inform the FOP entity about the\
      \ arrival of a new CLCW. The CLCW is processed only if reports COP-1 in effect,\
      \ and\r\n    # matches the virtual channel specified for FOP engine\r\n    #\
      \ param clcw: the CLCW to process\r\n    def clcw(self, clcw):\r\n        if\
      \ clcw.get_cop_in_effect() == Clcw.CopEffectType.COP1 and clcw.get_virtual_channel_id()\
      \ == self.virtual_channel_id:\r\n            self.fop_executor.submit(lambda:\
      \ self.process_clcw(clcw))\r\n\r\n    # Dispose the FOP entity\r\n    def dispose(self)\
      \ -> None:\r\n        self.fop_executor.submit(self.cancel_timer) \r\n     \
      \   self.fop_executor.submit(self.purge_wait_queue) \r\n        self.fop_executor.submit(self.purge_sent_queue)\r\
      \n        self.fop_executor.shutdown() \r\n        try:\r\n            self.fop_executor.shutdown(wait=True,\
      \ timeout=1)\r\n        except TimeoutError:\r\n            # Handle timeout\
      \ if the executor is still running after 1 second\r\n            Thread.currentThread().interrupt()\r\
      \n        self.low_level_executor.shutdown_now()\r\n\r\n    # ---------------------------------------------------------------------------------------------------------\r\
      \n    # FOP-1 actions defined as per CCSDS definition. All these actions are\
      \ performed by the state transitions\r\n    # and executed by the fopExecutor\
      \ service. Thread access is enforced to avoid misuse.\r\n    # ---------------------------------------------------------------------------------------------------------\r\
      \n\r\n    # Clear the sent_queue by generating a 'Negative Confirm Response\
      \ to Request to Transfer FDU' for each Transfer Frame on the queue and deleting\
      \ the Transfer Frame\r\n    def purge_sent_queue(self) -> None:\r\n        for\
      \ tfs in self.sent_queue:\r\n            if tfs.get_frame().get_frame_type()\
      \ == TcTransferFrame.FrameType.BC and self.pending_init_ad.get() is not None:\r\
      \n                # Directive (not on the standard)\r\n                directive\
      \ = self.pending_init_ad.get_and_set(None)\r\n                for o in self.observers:\r\
      \n                    o.directive_notification(self, FopOperationStatus.NEGATIVE_CONFIRM,\
      \ directive[0], directive[1], directive[2])\r\n            else:\r\n       \
      \         # Frame\r\n                for o in self.observers:\r\n          \
      \          o.transfer_notification(self, FopOperationStatus.NEGATIVE_CONFIRM,\
      \ tfs.get_frame())\r\n        self.sent_queue.clear()\r\n\r\n    # Clear the\
      \ Wait_Queue and generating a 'Reject Response to Request to Transfer FDU' for\
      \ the queued FDU\r\n    def purge_wait_queue(self) -> None:\r\n        if self.wait_queue.get()\
      \ is not None:\r\n            self.reject(self.wait_queue.get())\r\n       \
      \ self.wait_queue.set(None)\r\n\r\n    # Includes all the functions necessary\
      \ to prepare a Type-AD Transfer Frame for transmission\r\n    # param frame:\
      \ the frame to send\r\n    def transmit_type_ad_frame(self, frame) -> None:\r\
      \n        sent_queue_was_empty = len(self.sent_queue) == 0\r\n        self.sent_queue.append(self.TransferFrameStatus(frame))\
      \ # Add frame to sent_queue\r\n        if sent_queue_was_empty:\r\n        \
      \    self.transmission_count = 1\r\n        self.restart_timer() # Start transmit\
      \ timeout timer\r\n        self.set_ad_out_ready_flag(False)\r\n        self.low_level_executor.submit(lambda:\
      \ self.forward_to_output(frame)) # Forward frame to output and generate the\
      \ necessary response\r\n\r\n    # Includes all the functions necessary to prepare\
      \ a Type-BC Transfer Frame for transmission\r\n    # param frame: the frame\
      \ to send\r\n    def transmit_type_bc_frame(self, frame) -> None:\r\n      \
      \  self.sent_queue.append(self.TransferFrameStatus(frame)) # Add frame to sent_queue\r\
      \n        self.transmission_count = 1\r\n        self.restart_timer()\r\n  \
      \      self.set_bc_out_ready_flag(False)\r\n        self.low_level_executor.submit(lambda:\
      \ self.forward_to_output(frame)) # Forward frame to output and generate the\
      \ necessary response\r\n\r\n    # Includes all the functions necessary to prepare\
      \ a Type-BD Transfer Frame for transmission\r\n    # param frame: the frame\
      \ to send\r\n    def transmit_type_bd_frame(self, frame) -> None:\r\n      \
      \  self.set_bd_out_ready_flag(False)\r\n        self.low_level_executor.submit(lambda:\
      \ self.forward_to_output(frame)) # Forward frame to output and generate the\
      \ necessary response\r\n    \r\n    # Flag AD frames in sent_queue as to be\
      \ retransmitted\r\n    def initiate_ad_retransmission(self) -> None:\r\n   \
      \     self.transmission_count += 1\r\n        self.restart_timer()\r\n     \
      \   for o in self.sent_queue:\r\n            if o.get_frame().get_frame_type()\
      \ == TcTransferFrame.FrameType.AD:\r\n                o.set_to_be_retransmitted(True)\r\
      \n\r\n    # Flag BC frames in sent_queue as to be retransmitted\r\n    def initiate_bc_retransmission(self):\r\
      \n        self.transmission_count += 1\r\n        self.restart_timer() \r\n\
      \        for o in self.sent_queue:\r\n            if o.get_frame().get_frame_type()\
      \ == TcTransferFrame.FrameType.BC:\r\n                o.set_to_be_retransmitted(True)\r\
      \n\r\n    # Remove acknowledged frames from sent_queue\r\n    # param clcw:\
      \ the CLCW\r\n    def remove_ack_frames_from_sent_queue(self, clcw):\r\n   \
      \     acked = True\r\n        nr_report_value = clcw.get_report_value()\r\n\
      \        expander = {(nr_report_value - 1 - i + 256) % 256 for i in range(self.fop_sliding_window)}\
      \ # Set of values indicating NN(R) of accepted frames\r\n        while acked\
      \ and len(self.sent_queue) > 0:\r\n            next_ = self.sent_queue[0]\r\n\
      \            if next_.get_frame().get_frame_type() == TcTransferFrame.FrameType.BC:\r\
      \n                raise RuntimeError(\"No BC frames should be present in the\
      \ sent queue when calling remove_ack_frames_from_sent_queue()\")\r\n\r\n   \
      \         current_nnr = next_.get_frame().get_virtual_channel_frame_count()\
      \ # Get NN(R) of oldest frame in sent_queue\r\n            if current_nnr in\
      \ expander:\r\n                self.confirm(next_.get_frame()) # Send positive\
      \ confirm response for frame\r\n                self.sent_queue.pop(0) # Remove\
      \ frame from sent queue\r\n                self.expected_ack_frame_sequence_number\
      \ = (self.expected_ack_frame_sequence_number + 1) % 256 # Update NN(R)\r\n \
      \               self.transmission_count = 1 # Reset transmission_count to 1\r\
      \n                acked = True\r\n            else:\r\n                acked\
      \ = False\r\n\r\n    # Look for BC frames flagged as to retransmit in sent_queue\
      \ and initiate retransmission \r\n    def look_for_directive(self):\r\n    \
      \    if not self.bc_out_ready_flag:\r\n            pass\r\n        else:\r\n\
      \            opt_bc_frame = next((o for o in self.sent_queue if o.get_frame().get_frame_type()\
      \ == TcTransferFrame.FrameType.BC and o.is_to_be_retransmitted()), None)\r\n\
      \            if opt_bc_frame is not None:\r\n                self.set_bc_out_ready_flag(False)\r\
      \n                opt_bc_frame.set_to_be_retransmitted(False)\r\n          \
      \      self.low_level_executor.submit(lambda: self.forward_to_output(opt_bc_frame.get_frame()))\r\
      \n\r\n    # Look for AD frames flagged as to retransmit in sent_queue and initiate\
      \ retransmission or look for AD frame in wait_queue and transmit \r\n    def\
      \ look_for_frame(self):\r\n        if not self.ad_out_ready_flag:\r\n      \
      \      pass\r\n        else:\r\n            opt_ad_frame = next((o for o in\
      \ self.sent_queue if o.get_frame().get_frame_type() == TcTransferFrame.FrameType.AD\
      \ and o.is_to_be_retransmitted()), None)\r\n            if opt_ad_frame is not\
      \ None: # Initiate retransmission if there are AD frames to retransmit\r\n \
      \               opt_ad_frame.set_to_be_retransmitted(False)\r\n            \
      \    self.set_ad_out_ready_flag(False)\r\n                self.low_level_executor.submit(lambda:\
      \ self.forward_to_output(opt_ad_frame.get_frame()))\r\n            else: # Transmit\
      \ AD frame in wait_queue if fop_sliding_window not exceeded\r\n            \
      \    if self.wait_queue.get() is not None and self.wait_queue.get().get_frame_type()\
      \ == TcTransferFrame.FrameType.AD and self.less_than(self.wait_queue.get().get_virtual_channel_frame_count(),\
      \ (self.expected_ack_frame_sequence_number + self.fop_sliding_window), self.fop_sliding_window):\r\
      \n                    to_transmit = self.wait_queue.get_and_set(None)\r\n  \
      \                  self.accept(to_transmit)\r\n                    self.transmit_type_ad_frame(to_transmit)\r\
      \n                else:\r\n                    pass\r\n\r\n    # Generate accept\
      \ response to frame transfer request\r\n    # param frame: the frame to notify\
      \ as accepted\r\n    def accept(self, frame):\r\n        for o in self.observers:\r\
      \n            o.transfer_notification(self, FopOperationStatus.ACCEPT_RESPONSE,\
      \ frame)\r\n        if self.pending_accept_reject_frame.get() == frame:\r\n\
      \            self.pending_accept_reject_result.set(FopOperationStatus.ACCEPT_RESPONSE)\r\
      \n            self.pending_accept_reject_frame.notify_all()\r\n\r\n    # Generate\
      \ accept response to directive request\r\n    # param tag: the directive tag\
      \ to report as accepted\r\n    # param directive: the directive type\r\n   \
      \ # param qualifier: the qualifier\r\n    def accept_directive(self, tag, directive,\
      \ qualifier):\r\n        for o in self.observers:\r\n            o.directive_notification(self,\
      \ FopOperationStatus.ACCEPT_RESPONSE, tag, directive, qualifier)\r\n\r\n   \
      \ # Generate reject response to frame transfer request\r\n    # param frame:\
      \ the frame to notify as rejected\r\n    def reject(self, frame):\r\n      \
      \  if self.pending_accept_reject_frame.get() == frame:\r\n            self.pending_accept_reject_result.set(FopOperationStatus.ACCEPT_RESPONSE)\r\
      \n            self.pending_accept_reject_frame.notify_all()\r\n        for o\
      \ in self.observers:\r\n            o.transfer_notification(self, FopOperationStatus.REJECT_RESPONSE,\
      \ frame)\r\n\r\n    # Generate reject response to directive request\r\n    #\
      \ param tag: the directive tag to report as rejected\r\n    # param directive:\
      \ the directive type\r\n    # param qualifier: the qualifier\r\n    def reject_directive(self,\
      \ tag, directive, qualifier):\r\n        for o in self.observers:\r\n      \
      \      o.directive_notification(self, FopOperationStatus.REJECT_RESPONSE, tag,\
      \ directive, qualifier)\r\n\r\n    # Reject called by event handlers of the\
      \ fop state\r\n    # param fop_event: the event linked to the action to reject\r\
      \n    def reject_event(self, fop_event):\r\n        if fop_event.get_frame()\
      \ is not None:\r\n            self.reject(fop_event.get_frame())\r\n       \
      \ elif fop_event.get_directive_id() is not None:\r\n            self.reject_directive(fop_event.get_directive_tag(),\
      \ fop_event.get_directive_id(), fop_event.get_directive_qualifier())\r\n   \
      \     else:\r\n            raise ValueError(\"FOP event \" + fop_event.get_directive_id()\
      \ + \" not recognised for reject\")\r\n\r\n    # Generate positive confirm response\
      \ to frame transfer request\r\n    def confirm(self, frame):\r\n        for\
      \ o in self.observers:\r\n            o.transfer_notification(self, FopOperationStatus.POSITIVE_CONFIRM,\
      \ frame)\r\n\r\n    # Generate positive confirm response to directive request\r\
      \n    def confirm_directive(self, tag, directive, qualifier):\r\n        for\
      \ o in self.observers:\r\n            o.directive_notification(self, FopOperationStatus.POSITIVE_CONFIRM,\
      \ tag, directive, qualifier)\r\n\r\n    # Add frame to wait_queue\r\n    def\
      \ add_to_wait_queue(self, fop_event):\r\n        self.wait_queue.set(fop_event.get_frame())\r\
      \n\r\n    # Initialise fop engine for AD service\r\n    def initialise(self):\r\
      \n        self.purge_sent_queue()\r\n        self.purge_wait_queue()\r\n   \
      \     self.transmission_count = 1\r\n        self.suspend_state = 0\r\n\r\n\
      \    # Generate alert code \r\n    # param code: the alert code\r\n    def alert(self,\
      \ code):\r\n        self.cancel_timer()\r\n        self.purge_sent_queue()\r\
      \n        self.purge_wait_queue()\r\n        for o in self.observers:\r\n  \
      \          o.alert(self, code)\r\n\r\n    # Generate suspend notification\r\n\
      \    def suspend(self):\r\n        for o in self.observers:\r\n            o.suspend(self)\r\
      \n\r\n    # Resume AD service\r\n    def resume(self):\r\n        self.restart_timer()\r\
      \n        self.suspend_state = 0\r\n\r\n    # Restart transmit timeout timer\r\
      \n    def restart_timer(self):\r\n        with self.fop_timer_lock:\r\n    \
      \        if self.current_timer is not None:\r\n              self.current_timer.cancel()\r\
      \n              self.current_timer = None\r\n            self.current_timer\
      \ = Timer(self.timer_initial_value, self.timer_expired)\r\n            self.current_timer.start()\r\
      \n\r\n    # Cancel transmit timeout timer\r\n    def cancel_timer(self):\r\n\
      \        if self.current_timer is not None:\r\n            self.current_timer.cancel()\r\
      \n            self.current_timer = None\r\n\r\n    # Set fop_sliding_window\
      \ value\r\n    def set_fop_sliding_window(self, fop_sliding_window):\r\n   \
      \     self.fop_sliding_window = fop_sliding_window\r\n        print(\"Fop Sliding\
      \ Window set to: \", fop_sliding_window)\r\n\r\n    # Set transmit timeout t1\
      \ initial value\r\n    def set_t1_initial(self, t1_initial):\r\n        self.timer_initial_value\
      \ = t1_initial\r\n        print(\"T1 initial set to: \", t1_initial)\r\n\r\n\
      \    # Set transmission limit value\r\n    def set_transmission_limit(self,\
      \ limit):\r\n        self.transmission_limit = limit\r\n        print(\"Transmission\
      \ limit set to: \", limit)\r\n\r\n    # Set timeout type\r\n    def set_timeout_type(self,\
      \ type_):\r\n        self.timeout_type = type_\r\n        print(\"Timeout type\
      \ set to: \", type_)\r\n\r\n    # Set ad_out_ready_flag\r\n    def set_ad_out_ready_flag(self,\
      \ flag):\r\n        self.ad_out_ready_flag = flag\r\n\r\n    # Set bc_out_ready_flag\r\
      \n    def set_bc_out_ready_flag(self, flag):\r\n        self.bc_out_ready_flag\
      \ = flag\r\n\r\n    # Set bd_out_ready_flag\r\n    def set_bd_out_ready_flag(self,\
      \ flag):\r\n        self.bd_out_ready_flag = flag\r\n        self.pending_accept_reject_frame.notify_all()\r\
      \n\r\n    # Request the FOP engine to transmit a BC unlock frame\r\n    def\
      \ transmit_type_bc_frame_unlock(self, tag):\r\n        frame = self.bc_frame_unlock_factory(tag)\r\
      \n        self.transmit_type_bc_frame(frame)\r\n\r\n    # Request the FOP engine\
      \ to transmit a BC Set V(R) frame\r\n    def transmit_type_bc_frame_set_vr(self,\
      \ tag, vr):\r\n        frame = self.bc_frame_set_vr_factory(vr,tag)\r\n    \
      \    self.transmit_type_bc_frame(frame)\r\n\r\n    # Set suspend state ss\r\n\
      \    def set_suspend_state(self, suspend_state):\r\n        self.suspend_state\
      \ = suspend_state\r\n\r\n    # Update transmitter frame sequence number V(S)\
      \ and expected_ack_frame_sequence_number NN(R) based on the new V(R) value\r\
      \n    def prepare_for_set_vr(self, vstarr):\r\n        self.next_virtual_channel_frame_counter_setter(vstarr)\r\
      \n        self.expected_ack_frame_sequence_number = vstarr\r\n\r\n    # Set\
      \ transmitter frame sequence number V(S) \r\n    def set_vs(self, vstars):\r\
      \n        self.next_virtual_channel_frame_counter_setter(vstars)\r\n       \
      \ self.expected_ack_frame_sequence_number = vstars\r\n        print(\"V(S) set\
      \ to: \", vstars)\r\n\r\n    # Register initiate AD directive\r\n    def register_pending_init_ad(self,\
      \ directive_tag, directive_id, directive_qualifier):\r\n        self.pending_init_ad.set([directive_tag,\
      \ directive_id, directive_qualifier])\r\n\r\n    # Confirm initialisation by\
      \ initiate AD with CLCW directive\r\n    def confirm_pending_init_ad_with_clcw(self,\
      \ clcw):\r\n        pending_directive = self.pending_init_ad.get_and_set(None)\r\
      \n        if pending_directive is not None:\r\n            self.set_vs(clcw.get_report_value())\r\
      \n            self.confirm_directive(pending_directive[0], pending_directive[1],\
      \ pending_directive[2])\r\n\r\n    # Confirm initialisation by initiate AD with\
      \ Unlock/Set V(R) directive\r\n    def confirm_pending_init_ad_with_bc_frame(self):\r\
      \n        pending_directive = self.pending_init_ad.get_and_set(None)\r\n   \
      \     if pending_directive is not None:\r\n            self.confirm_directive(pending_directive[0],\
      \ pending_directive[1], pending_directive[2])\r\n\r\n    # Remove BC frame from\
      \ sent_queue\r\n    def release_bc_frame(self):\r\n        opt_bc_frame = next((o\
      \ for o in self.sent_queue if o.get_frame().get_frame_type() == TcTransferFrame.FrameType.BC),\
      \ None)\r\n        if opt_bc_frame is not None:\r\n            self.sent_queue.remove(opt_bc_frame)\r\
      \n\r\n    # ---------------------------------------------------------------------------------------------------------\r\
      \n    # FOP-1 methods performed by the fopExecutor (thread confinement)\r\n\
      \    # ---------------------------------------------------------------------------------------------------------\r\
      \n    # Determine FopEvent event based on CLCW received\r\n    def process_clcw(self,\
      \ clcw):\r\n        event = None\r\n        print(\"N(R)=\",clcw.get_report_value())\r\
      \n        print(\"V(S)=\",self.next_virtual_channel_frame_counter_getter())\r\
      \n        print(\"NN(R)=\",self.expected_ack_frame_sequence_number)\r\n    \
      \    if not clcw.is_lockout_flag():\r\n            if clcw.get_report_value()\
      \ == self.next_virtual_channel_frame_counter_getter():\r\n                if\
      \ not clcw.is_retransmit_flag():\r\n                    if not clcw.is_wait_flag():\r\
      \n                        if clcw.get_report_value() == self.expected_ack_frame_sequence_number:\r\
      \n                            event = FopEvent(FopEvent.EventNumber.E1, clcw=clcw,\
      \ ss=self.suspend_state)\r\n                        else:\r\n              \
      \              event = FopEvent(FopEvent.EventNumber.E2, clcw=clcw, ss=self.suspend_state)\r\
      \n                    else:\r\n                        event = FopEvent(FopEvent.EventNumber.E3,\
      \ clcw=clcw, ss=self.suspend_state)\r\n                else:\r\n           \
      \         event = FopEvent(FopEvent.EventNumber.E4, clcw=clcw, ss=self.suspend_state)\r\
      \n            elif self.less_than(clcw.get_report_value(), self.next_virtual_channel_frame_counter_getter(),\
      \ self.fop_sliding_window) and (clcw.get_report_value() == self.expected_ack_frame_sequence_number\
      \ or self.greater_than(clcw.get_report_value(), self.expected_ack_frame_sequence_number,\
      \ self.fop_sliding_window)):\r\n                if not clcw.is_retransmit_flag():\r\
      \n                    if not clcw.is_wait_flag():\r\n                      \
      \  if clcw.get_report_value() == self.expected_ack_frame_sequence_number:\r\n\
      \                            event = FopEvent(FopEvent.EventNumber.E5, clcw=clcw,\
      \ ss=self.suspend_state)\r\n                        else:\r\n              \
      \              event = FopEvent(FopEvent.EventNumber.E6, clcw=clcw, ss=self.suspend_state)\r\
      \n                    else:\r\n                        event = FopEvent(FopEvent.EventNumber.E7,\
      \ clcw=clcw, ss=self.suspend_state)\r\n                else:\r\n           \
      \         if self.transmission_limit == 1:\r\n                        event\
      \ = FopEvent(FopEvent.EventNumber.E101 if clcw.get_report_value() != self.expected_ack_frame_sequence_number\
      \ else FopEvent.EventNumber.E102, clcw=clcw, ss=self.suspend_state)\r\n    \
      \                else:\r\n                        if clcw.get_report_value()\
      \ != self.expected_ack_frame_sequence_number:\r\n                          \
      \  event = FopEvent(FopEvent.EventNumber.E8 if not clcw.is_wait_flag() else\
      \ FopEvent.EventNumber.E9, clcw=clcw, ss=self.suspend_state)\r\n           \
      \             else:\r\n                            if self.transmission_count\
      \ < self.transmission_limit:\r\n                                event = FopEvent(FopEvent.EventNumber.E10\
      \ if not clcw.is_wait_flag() else FopEvent.EventNumber.E11, clcw=clcw, ss=self.suspend_state)\r\
      \n                            else:\r\n                                event\
      \ = FopEvent(FopEvent.EventNumber.E12 if not clcw.is_wait_flag() else FopEvent.EventNumber.E103,\
      \ clcw=clcw, ss=self.suspend_state)\r\n            else:\r\n               \
      \ event = FopEvent(FopEvent.EventNumber.E13, clcw=clcw, ss=self.suspend_state)\r\
      \n        else:\r\n            event = FopEvent(FopEvent.EventNumber.E14, clcw=clcw,\
      \ ss=self.suspend_state)\r\n        self.apply_state_transition(event)\r\n\r\
      \n\r\n    # Perform comparison to check if num is less than otherNum mod 256,\
      \ given the provided window.\r\n    # Basically, the window tells how much other_num\
      \ can be greater than num, including wrap around.\r\n    # param num: the first\
      \ term to compare\r\n    # param other_num: the second term to compare\r\n \
      \   # param window: the window size\r\n    # return true if num is less than\
      \ otherNum, otherwise false\r\n    def less_than(self, num, other_num, window):\r\
      \n        # Expand num to window elements\r\n        expanded_set = set((num\
      \ + 1 + i) % 256 for i in range(window))\r\n        # If other_num is within\
      \ the expanded set, return True, else return False\r\n        return other_num\
      \ in expanded_set\r\n\r\n    # Perform comparison to check if num is greater\
      \ than other_num mod 256, given the provided window.\r\n    # Basically, the\
      \ window tells how much num can be greater than other_num, including wrap around.\r\
      \n    # param num: the first term to compare\r\n    # param other_num: the second\
      \ term to compare\r\n    # param window: the window size\r\n    # return true\
      \ if num is greater than otherNum, otherwise false\r\n    def greater_than(self,\
      \ num, other_num, window):\r\n        # Expand other_num to window elements\r\
      \n        expanded_set = set((other_num + 1 + i) % 256 for i in range(window))\r\
      \n        # If num is within the expanded set, return True, else return False\r\
      \n        return num in expanded_set\r\n\r\n    # Determine FopEvent event when\
      \ transmit timeout timer expired\r\n    def process_timer_expired(self):\r\n\
      \        event = None\r\n        if self.transmission_count < self.transmission_limit:\r\
      \n            event = FopEvent(FopEvent.EventNumber.E16 if self.timeout_type\
      \ == 0 else FopEvent.EventNumber.E104, ss=self.suspend_state)\r\n        else:\r\
      \n            event = FopEvent(FopEvent.EventNumber.E17 if self.timeout_type\
      \ == 0 else FopEvent.EventNumber.E18, ss=self.suspend_state)\r\n        self.apply_state_transition(event)\r\
      \n\r\n    # Determine FopEvent event when request to transmit BD frame received\r\
      \n    def process_bd_frame(self, frame):\r\n        event = FopEvent(FopEvent.EventNumber.E21\
      \ if self.bd_out_ready_flag else FopEvent.EventNumber.E22, frame=frame, ss=self.suspend_state)\r\
      \n        self.apply_state_transition(event)\r\n\r\n    # Determine FopEvent\
      \ event when request to transmit AD frame received\r\n    def process_ad_frame(self,\
      \ frame):\r\n        event = None\r\n        if self.wait_queue.get() is None:\r\
      \n            event = FopEvent(FopEvent.EventNumber.E19, frame=frame, ss=self.suspend_state)\r\
      \n        else:\r\n            event = FopEvent(FopEvent.EventNumber.E20, frame=frame,\
      \ ss=self.suspend_state)\r\n        self.apply_state_transition(event)\r\n\r\
      \n    # Determine FopEvent event when directive received\r\n    def process_directive(self,\
      \ tag, directive, qualifier):\r\n        event = None\r\n        if (directive\
      \ == FopDirective.INIT_AD_WITHOUT_CLCW):\r\n            event = FopEvent(FopEvent.EventNumber.E23,\
      \ directive_tag=tag, directive_id=directive, directive_qualifier=qualifier,\
      \ ss=self.suspend_state)\r\n        elif (directive == FopDirective.INIT_AD_WITH_CLCW):\r\
      \n            event = FopEvent(FopEvent.EventNumber.E24, directive_tag=tag,\
      \ directive_id=directive, directive_qualifier=qualifier, ss=self.suspend_state)\r\
      \n        elif (directive == FopDirective.INIT_AD_WITH_UNLOCK):\r\n        \
      \    event = FopEvent(FopEvent.EventNumber.E25 if self.bc_out_ready_flag else\
      \ FopEvent.EventNumber.E26, directive_tag=tag, directive_id=directive, directive_qualifier=qualifier,\
      \ ss=self.suspend_state)\r\n        elif (directive == FopDirective.INIT_AD_WITH_SET_V_R):\r\
      \n            event = FopEvent(FopEvent.EventNumber.E27 if self.bc_out_ready_flag\
      \ else FopEvent.EventNumber.E28, directive_tag=tag, directive_id=directive,\
      \ directive_qualifier=qualifier, ss=self.suspend_state)\r\n        elif (directive\
      \ == FopDirective.TERMINATE):\r\n            event = FopEvent(FopEvent.EventNumber.E29,\
      \ directive_tag=tag, directive_id=directive, directive_qualifier=qualifier,\
      \ ss=self.suspend_state)\r\n        elif (directive == FopDirective.RESUME):\r\
      \n            suspend_state_mapping = {\r\n                0: FopEvent.EventNumber.E30,\r\
      \n                1: FopEvent.EventNumber.E31,\r\n                2: FopEvent.EventNumber.E32,\r\
      \n                3: FopEvent.EventNumber.E33,\r\n                4: FopEvent.EventNumber.E34\r\
      \n            }\r\n            event = FopEvent(suspend_state_mapping.get(self.suspend_state,\
      \ FopEvent.EventNumber.E40), directive_tag=tag, directive_id=directive, directive_qualifier=qualifier,\
      \ ss=self.suspend_state)\r\n        elif (directive == FopDirective.SET_V_S):\r\
      \n            event = FopEvent(FopEvent.EventNumber.E35, directive_tag=tag,\
      \ directive_id=directive, directive_qualifier=qualifier, ss=self.suspend_state)\r\
      \n        elif (directive == FopDirective.SET_FOP_SLIDING_WINDOW):\r\n     \
      \       event = FopEvent(FopEvent.EventNumber.E36, directive_tag=tag, directive_id=directive,\
      \ directive_qualifier=qualifier, ss=self.suspend_state)\r\n        elif (directive\
      \ == FopDirective.SET_T1_INITIAL):\r\n            event = FopEvent(FopEvent.EventNumber.E37,\
      \ directive_tag=tag, directive_id=directive, directive_qualifier=qualifier,\
      \ ss=self.suspend_state)\r\n        elif (directive == FopDirective.SET_TRANSMISSION_LIMIT):\r\
      \n            event = FopEvent(FopEvent.EventNumber.E38, directive_tag=tag,\
      \ directive_id=directive, directive_qualifier=qualifier, ss=self.suspend_state)\r\
      \n        elif (directive == FopDirective.SET_TIMEOUT_TYPE):\r\n           \
      \ event = FopEvent(FopEvent.EventNumber.E39, directive_tag=tag, directive_id=directive,\
      \ directive_qualifier=qualifier, ss=self.suspend_state)\r\n        else:\r\n\
      \            event = FopEvent(FopEvent.EventNumber.E40, directive_tag=tag, directive_id=directive,\
      \ directive_qualifier=qualifier, ss=self.suspend_state)\r\n        self.apply_state_transition(event)\r\
      \n\r\n    # Determine FopEvent event when response from lower layer received\r\
      \n    def process_lower_layer(self, frame, accepted):\r\n        event = None\r\
      \n        frame_type_mapping = {\r\n            TcTransferFrame.FrameType.AD:\
      \ (FopEvent.EventNumber.E41, FopEvent.EventNumber.E42),\r\n            TcTransferFrame.FrameType.BC:\
      \ (FopEvent.EventNumber.E43, FopEvent.EventNumber.E44),\r\n            TcTransferFrame.FrameType.BD:\
      \ (FopEvent.EventNumber.E45, FopEvent.EventNumber.E46)\r\n        }\r\n    \
      \    frame_type = frame.get_frame_type()\r\n        if frame_type in frame_type_mapping:\r\
      \n            accepted_event, rejected_event = frame_type_mapping[frame_type]\r\
      \n            event = FopEvent(accepted_event if accepted else rejected_event,\
      \ frame=frame, ss=self.suspend_state)\r\n        else:\r\n            raise\
      \ ValueError(\"Frame type {} not supported\".format(frame_type))\r\n       \
      \ self.apply_state_transition(event)\r\n\r\n    # Generate status report\r\n\
      \    def report_status(self, previous_state, current_state, number):\r\n   \
      \     status = FopStatus(self.expected_ack_frame_sequence_number, len(self.sent_queue),\
      \ self.wait_queue.get() is not None, self.ad_out_ready_flag, self.bc_out_ready_flag,\
      \ self.bd_out_ready_flag, previous_state, current_state, number)\r\n       \
      \ for observer in self.observers:\r\n            observer.status_report(self,\
      \ status)\r\n        if number in [FopEvent.EventNumber.E22, FopEvent.EventNumber.E45,\
      \ FopEvent.EventNumber.E46]:\r\n            self.pending_event_result.set(number)\r\
      \n            self.pending_accept_reject_frame.notify_all()\r\n\r\n    # Call\
      \ the functions to perform actions and transit to new state based on the event\r\
      \n    def apply_state_transition(self, event):\r\n        print(\"Event=\",event.get_number())\r\
      \n        previous_state = self.state.get_state()\r\n        self.state = self.state.event(event)\r\
      \n        current_state = self.state.get_state()\r\n        print(\"state:\"\
      , self.state.get_state())\r\n        self.report_status(previous_state, current_state,\
      \ event.get_number())\r\n\r\n    # Call output to forward the frame to the lower\
      \ layer and receive response from the lower layer\r\n    def forward_to_output(self,\
      \ frame):\r\n        result = False\r\n        if self.output is not None:\r\
      \n            with self.output_lock:\r\n                result = self.output(frame)\r\
      \n        self.lower_layer(frame, result)\r\n\r\n    # Process response from\
      \ lower layer\r\n    def lower_layer(self, frame, accepted):\r\n        self.fop_executor.submit(lambda:\
      \ self.process_lower_layer(frame, accepted))\r\n\r\n    # ---------------------------------------------------------------------------------------------------------\r\
      \n    # Other members\r\n    # ---------------------------------------------------------------------------------------------------------\r\
      \n    # Function to call when timer expires\r\n    def timer_expired(self):\r\
      \n        print(\"TIMER EXPIRED\")\r\n        if self.current_timer is not None:\r\
      \n            self.process_timer_expired()\r\n\r\n    # Store retransmit information\
      \ of each transfer frame in sent_queue   \r\n    class TransferFrameStatus:\r\
      \n        def __init__(self, frame):\r\n            self.frame = frame\r\n \
      \           self.to_be_retransmitted = False\r\n\r\n        def set_to_be_retransmitted(self,\
      \ to_be_retransmitted):\r\n            self.to_be_retransmitted = to_be_retransmitted\r\
      \n\r\n        def is_to_be_retransmitted(self):\r\n            return self.to_be_retransmitted\r\
      \n\r\n        def get_frame(self):\r\n            return self.frame\r\n\r\n"
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [712, 284.0]
    rotation: 0
    state: enabled
- name: FopEvent
  id: epy_module
  parameters:
    alias: ''
    comment: ''
    source_code: "from enum import Enum\r\n\r\n#Enumerate fop events\r\nclass FopEvent:\r\
      \n    class EventNumber(Enum):\r\n        E1 = 1\r\n        E2 = 2\r\n     \
      \   E3 = 3\r\n        E4 = 4\r\n        E5 = 5\r\n        E6 = 6\r\n       \
      \ E7 = 7\r\n        E101 = 101\r\n        E102 = 102\r\n        E8 = 8\r\n \
      \       E9 = 9\r\n        E10 = 10\r\n        E11 = 11\r\n        E12 = 12\r\
      \n        E103 = 103\r\n        E13 = 13\r\n        E14 = 14\r\n        E15\
      \ = 15\r\n        E16 = 16\r\n        E104 = 104\r\n        E17 = 17\r\n   \
      \     E18 = 18\r\n        E19 = 19\r\n        E20 = 20\r\n        E21 = 21\r\
      \n        E22 = 22\r\n        E23 = 23\r\n        E24 = 24\r\n        E25 =\
      \ 25\r\n        E26 = 26\r\n        E27 = 27\r\n        E28 = 28\r\n       \
      \ E29 = 29\r\n        E30 = 30\r\n        E31 = 31\r\n        E32 = 32\r\n \
      \       E33 = 33\r\n        E34 = 34\r\n        E35 = 35\r\n        E36 = 36\r\
      \n        E37 = 37\r\n        E38 = 38\r\n        E39 = 39\r\n        E40 =\
      \ 40\r\n        E41 = 41\r\n        E42 = 42\r\n        E43 = 43\r\n       \
      \ E44 = 44\r\n        E45 = 45\r\n        E46 = 46\r\n\r\n    def __init__(self,\
      \ number, clcw=None, frame=None, directive_tag=None, directive_id=None, directive_qualifier=0,\
      \ ss=0):\r\n        self.number = number\r\n        self.clcw = clcw\r\n   \
      \     self.frame = frame\r\n        self.directive_tag = directive_tag\r\n \
      \       self.directive_id = directive_id\r\n        self.directive_qualifier\
      \ = directive_qualifier\r\n        self.ss = ss\r\n\r\n    def get_number(self):\r\
      \n        return self.number\r\n\r\n    def get_clcw(self):\r\n        return\
      \ self.clcw\r\n\r\n    def get_frame(self):\r\n        return self.frame\r\n\
      \r\n    def get_directive_tag(self):\r\n        return self.directive_tag\r\n\
      \r\n    def get_directive_id(self):\r\n        return self.directive_id\r\n\r\
      \n    def get_directive_qualifier(self):\r\n        return self.directive_qualifier\r\
      \n\r\n    def get_suspend_state(self):\r\n        return self.ss\r\n"
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [64, 412.0]
    rotation: 0
    state: enabled
- name: FopOperationStatus
  id: epy_module
  parameters:
    alias: ''
    comment: ''
    source_code: "from enum import Enum\r\n\r\n# Enumerate Fop response types\r\n\
      class FopOperationStatus(Enum):\r\n    ACCEPT_RESPONSE = 1\r\n    REJECT_RESPONSE\
      \ = 2\r\n    POSITIVE_CONFIRM = 3\r\n    NEGATIVE_CONFIRM = 4\r\n"
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [64, 476.0]
    rotation: 0
    state: enabled
- name: FopState
  id: epy_module
  parameters:
    alias: ''
    comment: ''
    source_code: "from enum import Enum\r\n\r\n# Enumerate fop states\r\nclass FopState(Enum):\r\
      \n    \r\n    # Normal state of the state machine when there are no recent errors\
      \ on\r\n    # the link and no incidents have occurred leading to flow control\
      \ problems\r\n    S1 = \"Active\"  # Active\r\n    # The state machine is in\
      \ the 'Retransmit without Wait' State (S2) while the 'Retransmit' Flag\r\n \
      \   # is 'on' in the CLCW of the Virtual Channel but no other exceptional circumstances\
      \ prevail.\r\n    S2 = \"Retransmit without wait\"  # Retransmit without wait\r\
      \n    # The state machine is in the 'Retransmit with Wait' State (S3) while\
      \ the 'Wait' Flag is 'on' in\r\n    # the CLCW of the Virtual Channel. (Some\
      \ Transfer Frames must always be retransmitted\r\n    # when the 'Wait' Flag\
      \ is reset, since the 'Wait' Flag is set only when at least one Transfer\r\n\
      \    # Frame has been discarded.) In this state the 'Retransmit' Flag will also\
      \ be set (as a\r\n    # consequence of the fact that Transfer Frames have been\
      \ lost).\r\n    S3 = \"Retransmit with wait\"  # Retransmit with wait\r\n  \
      \  # The state machine is in the 'Initializing without BC Frame' State (S4)\
      \ after receiving an\r\n    # 'Initiate AD Service (with CLCW check)' Directive\
      \ while in the 'Initial' State. A successful\r\n    # CLCW check will result\
      \ in a transition to S1.\r\n    S4 = \"Initializing without BC Frame\"  # Initialising\
      \ without BC Frame\r\n    # The state machine is in the 'Initializing with BC\
      \ Frame' State (S5) after receiving an 'Initiate\r\n    # AD Service (with Unlock)'\
      \ Directive or 'Initiate AD Service (with Set V(R))' Directive\r\n    # while\
      \ in the 'Initial' State with BC_Out_Flag = Ready. A successful transmission\
      \ of the\r\n    # Type-BC Transfer Frame and a subsequent 'clean' CLCW status\
      \ will result in a transition to\r\n    # S1.\r\n    S5 = \"Initializing with\
      \ BC Frame\"  # Initialising with BC Frame\r\n    # The state machine is in\
      \ the 'Initial' State (S6) whenever it is necessary to terminate an\r\n    #\
      \ ongoing service (this happens when a 'Terminate AD Service' Directive is received\
      \ or when\r\n    # an 'exception', i.e., an event that causes an 'Alert', occurs).\
      \ In principle, the 'Initial' State is\r\n    # the first state entered by the\
      \ state machine for a particular Virtual Channel.\r\n    # State S6 shall also\
      \ be used when the AD Service is suspended.\r\n    S6 = \"Initial\"  # Initial\r\
      \n\r\n    def __str__(self):\r\n        descriptions = {\r\n            FopState.S1:\
      \ \"Active\",\r\n            FopState.S2: \"Retransmit without wait\",\r\n \
      \           FopState.S3: \"Retransmit with wait\",\r\n            FopState.S4:\
      \ \"Initialising without BC Frame\",\r\n            FopState.S5: \"Initialising\
      \ with BC Frame\",\r\n            FopState.S6: \"Initial\",\r\n        }\r\n\
      \        return f\"{self.name} - {descriptions[self]}\"\r\n"
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [64, 540.0]
    rotation: 0
    state: enabled
- name: FopStatus
  id: epy_module
  parameters:
    alias: ''
    comment: ''
    source_code: "# Encapsulate fop status information\r\nclass FopStatus:\r\n   \
      \ def __init__(self, expected_ack_frame_sequence_number, sent_queue_items, wait_queue_full,\
      \ ad_out_ready_flag, bc_out_ready_flag, bd_out_ready_flag, previous_state, current_state,\
      \ event):\r\n        self.expected_ack_frame_sequence_number = expected_ack_frame_sequence_number\r\
      \n        self.sent_queue_items = sent_queue_items\r\n        self.wait_queue_full\
      \ = wait_queue_full\r\n        self.ad_out_ready_flag = ad_out_ready_flag\r\n\
      \        self.bc_out_ready_flag = bc_out_ready_flag\r\n        self.bd_out_ready_flag\
      \ = bd_out_ready_flag\r\n        self.previous_state = previous_state\r\n  \
      \      self.current_state = current_state\r\n        self.event = event\r\n\r\
      \n    def get_expected_ack_frame_sequence_number(self):\r\n        return self.expected_ack_frame_sequence_number\r\
      \n\r\n    def get_sent_queue_items(self):\r\n        return self.sent_queue_items\r\
      \n\r\n    def is_wait_queue_full(self):\r\n        return self.wait_queue_full\r\
      \n\r\n    def is_ad_out_ready_flag(self):\r\n        return self.ad_out_ready_flag\r\
      \n\r\n    def is_bc_out_ready_flag(self):\r\n        return self.bc_out_ready_flag\r\
      \n\r\n    def is_bd_out_ready_flag(self):\r\n        return self.bd_out_ready_flag\r\
      \n\r\n    def get_previous_state(self):\r\n        return self.previous_state\r\
      \n\r\n    def get_current_state(self):\r\n        return self.current_state\r\
      \n\r\n    def get_event(self):\r\n        return self.event\r\n\r\n    def __str__(self):\r\
      \n        return f\"FopStatus{{NN(R)={self.get_expected_ack_frame_sequence_number()},\
      \ \" \\\r\n               f\"previousState={self.get_previous_state()}, currentState={self.get_current_state()},\
      \ \" \\\r\n               f\"event={self.get_event()}, sentQueueItems={self.get_sent_queue_items()},\
      \ \" \\\r\n               f\"waitQueueFull={self.is_wait_queue_full()}, adOutReadyFlag={self.is_ad_out_ready_flag()},\
      \ \" \\\r\n               f\"bcOutReadyFlag={self.is_bc_out_ready_flag()}, bdOutReadyFlag={self.is_bd_out_ready_flag()}}}\"\
      \r\n"
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [64, 604.0]
    rotation: 0
    state: enabled
- name: IFopObserver
  id: epy_module
  parameters:
    alias: ''
    comment: ''
    source_code: "import numpy as np\r\nimport struct\r\n\r\nfrom overall_FopOperationStatus\
      \ import FopOperationStatus\r\nfrom overall_FopDirective import FopDirective\r\
      \nfrom overall_FopAlertCode import FopAlertCode\r\n\r\n# Pack response/acknowledgements\
      \ into correct TCP/IP message and transmit via TCP/IP back to ground station\
      \ \r\nclass IFopObserver:\r\n    def __init__(self, tcp_server, endian):\r\n\
      \        self.tcp_server = tcp_server\r\n        self.endian = endian\r\n\r\n\
      \    # Pack accept/reject/positive confirm/negative confirm for transfer requests\r\
      \n    def transfer_notification(self, engine, status, frame):\r\n        print(status)\r\
      \n        vcid = engine.virtual_channel_id\r\n        operation_type = frame.get_operation_tag()\
      \  \r\n        tag = frame.get_req_tag()   \r\n        if (status == FopOperationStatus.ACCEPT_RESPONSE):\r\
      \n          msg = self.accept_rej_response(operation_type, vcid, tag, 0, 0)\r\
      \n\r\n        elif (status == FopOperationStatus.REJECT_RESPONSE):\r\n     \
      \     msg = self.accept_rej_response(operation_type, vcid, tag, 1, 0)  # Unable\
      \ to get rej_info\r\n\r\n        elif (status == FopOperationStatus.POSITIVE_CONFIRM):\r\
      \n          msg = self.pos_neg_confirm_response(operation_type, vcid, tag, 0)\r\
      \n\r\n        elif (status == FopOperationStatus.NEGATIVE_CONFIRM):\r\n    \
      \      msg = self.pos_neg_confirm_response(operation_type, vcid, tag, 1)\r\n\
      \        self.tcp_server(msg) # Send to 'response_out' output port of COP Execute\
      \ \r\n        print(\"ack msg=\",self.bin_to_int32array(msg))\r\n\r\n    # Pack\
      \ accept/reject/positive confirm/negative confirm for directive requests\r\n\
      \    def directive_notification(self, engine, status, tag, directive, qualifier):\r\
      \n        print(status)\r\n        vcid = engine.virtual_channel_id\r\n    \
      \    operation_type = self.get_op_type(directive) # Get directive type\r\n \
      \       if (status == FopOperationStatus.ACCEPT_RESPONSE):\r\n          msg\
      \ = self.accept_rej_response(operation_type, vcid, tag, 0, 0)\r\n\r\n      \
      \  elif (status == FopOperationStatus.REJECT_RESPONSE):\r\n          msg = self.accept_rej_response(operation_type,\
      \ vcid, tag, 1, 0)  # Unable to get rej_info\r\n\r\n        elif (status ==\
      \ FopOperationStatus.POSITIVE_CONFIRM):\r\n          msg = self.pos_neg_confirm_response(operation_type,\
      \ vcid, tag, 0)\r\n\r\n        elif (status == FopOperationStatus.NEGATIVE_CONFIRM):\r\
      \n          msg = self.pos_neg_confirm_response(operation_type, vcid, tag, 1)\r\
      \n        self.tcp_server(msg) # Send to 'response_out' output port of COP Execute\r\
      \n\r\n    # Pack alert messages\r\n    def alert(self, engine, code):\r\n  \
      \      vcid = engine.virtual_channel_id\r\n        alert_code = self.get_alert_code(code)\r\
      \n        fop_identifier = 1  # Unable to get fop_identifier\r\n        msg\
      \ = self.alert_indication_msg(fop_identifier, vcid, alert_code)\r\n        print(\"\
      alert code=\",code)\r\n        self.tcp_server(msg) # Send to 'response_out'\
      \ output port of COP Execute\r\n        print(\"alert msg=\",self.bin_to_int32array(msg))\r\
      \n\r\n    # Pack suspend messages\r\n    def suspend(self, engine):\r\n    \
      \    vcid = engine.virtual_channel_id\r\n        fop_identifier = 1  # Unable\
      \ to get fop_identifier\r\n        msg = self.suspend_indication_msg(fop_identifier,\
      \ vcid)\r\n        self.tcp_server(msg) # Send to 'response_out' output port\
      \ of COP Execute\r\n        print(\"suspend msg=\",self.bin_to_int32array(msg))\r\
      \n\r\n    def status_report(self, engine, status):\r\n        pass\r\n\r\n \
      \   # Convert int32 to int8 array\r\n    def toint8(self, int32_value):\r\n\
      \        # Convert integer to bytes\r\n        byte_data = int32_value.to_bytes(4,\
      \ self.endian, signed=True)\r\n        # Convert bytes to list of int8\r\n \
      \       int8_array = [np.int8(byte) for byte in byte_data]\r\n        return\
      \ int8_array\r\n        \r\n    # Convert int32 to bytes\r\n    def int32tobytes(self,\
      \  int32_value):\r\n        if self.endian == 'big':\r\n            return struct.pack('>i',\
      \ int32_value)\r\n        else:\r\n            return struct.pack('<i', int32_value)\r\
      \n        \r\n    # Convert bytes to int32\r\n    def bin_to_int32array(self,\
      \ binary_data):\r\n        padding_needed = len(binary_data) % 4\r\n       \
      \ if padding_needed:\r\n            binary_data += b'\\x00' * (4 - padding_needed)\r\
      \n\r\n        int32_array = []\r\n        for i in range(0, len(binary_data),\
      \ 4):\r\n            if self.endian == 'big':\r\n                int32_value\
      \ = struct.unpack('>i', binary_data[i:i+4])[0]\r\n            else:\r\n    \
      \            int32_value = struct.unpack('<i', binary_data[i:i+4])[0]\r\n  \
      \          int32_array.append(int32_value)\r\n        return int32_array\r\n\
      \r\n    # Pack negative acknowledgement message\r\n    def neg_ack_msg(self):\r\
      \n        msg_size = 20 # 20 bytes default value\r\n        msg_size_array =\
      \ [(msg_size >> 64) & 0xFFFFFFFF,(msg_size >> 32) & 0xFFFFFFFF,msg_size & 0xFFFFFFFF]\
      \ # Split msg_size into 3 int32 values\r\n        neg_ack = -1\r\n        postamble\
      \ = -1234567890\r\n        msg = (                                         #\
      \ Convert from int32 values to binary\r\n           self.int32tobytes(msg_size_array[0])\
      \ +\r\n           self.int32tobytes(msg_size_array[1]) +\r\n           self.int32tobytes(msg_size_array[2])\
      \ +\r\n           self.int32tobytes(neg_ack) +\r\n           self.int32tobytes(postamble)\r\
      \n           )\r\n        self.tcp_server(msg) # Send to 'response_out' output\
      \ port of COP Execute \r\n        print(\"NEG_ACK_MSG\")\r\n        print(\"\
      neg ack msg=\",self.bin_to_int32array(msg))\r\n\r\n    # Build tcp message for\
      \ accept/reject response\r\n    def accept_rej_response(self, operation_type,\
      \ vcid, req_tag, response, rej_info):\r\n        #response: 0 for accept, 1\
      \ for reject   rej_info: 1 for invalid parameter limits, 2 for invalid check-sum,\
      \ 3 for tc modulator not reached, 4 for invalid vcid info, 5 for invalid license,\
      \ 6 for encoding error\r\n        msg_size = 36 # 36 bytes default value\r\n\
      \        msg_size_array = [(msg_size >> 64) & 0xFFFFFFFF,(msg_size >> 32) &\
      \ 0xFFFFFFFF,msg_size & 0xFFFFFFFF] # Split msg_size into 3 int32 values\r\n\
      \        output_flow_identifier = 0 # 0 for accept/rej response\r\n        if\
      \ (self.endian == 'big'):\r\n            response_status = np.array([0,0,rej_info,response])\
      \ # Byte 0: response Byte 1: rej_info\r\n        else:\r\n            response_status\
      \ = np.array([response,rej_info,0,0]) # Byte 0: response Byte 1: rej_info\r\n\
      \        postamble = -1234567890\r\n        msg = (                        \
      \                 # Convert from int32 values to binary\r\n           self.int32tobytes(msg_size_array[0])\
      \ +\r\n           self.int32tobytes(msg_size_array[1]) +\r\n           self.int32tobytes(msg_size_array[2])\
      \ +\r\n           self.int32tobytes(output_flow_identifier) +\r\n          \
      \ self.int32tobytes(operation_type) + \r\n           self.int32tobytes(vcid)\
      \ +\r\n           self.int32tobytes(req_tag) +\r\n           struct.pack('b'\
      \ * len(response_status), *response_status) +\r\n           self.int32tobytes(postamble)\r\
      \n           )\r\n        return msg # Return tcp msg in binary\r\n\r\n    #\
      \ Build tcp message for positive/negative confirm response\r\n    def pos_neg_confirm_response(self,\
      \ operation_type, vcid, req_tag, response): #response: 0 for positive, 1 for\
      \ negative\r\n        msg_size = 36 # 36 bytes default value\r\n        msg_size_array\
      \ = [(msg_size >> 64) & 0xFFFFFFFF,(msg_size >> 32) & 0xFFFFFFFF,msg_size &\
      \ 0xFFFFFFFF] # Split msg_size into 3 int32 values\r\n        output_flow_identifier\
      \ = 1 # 1 for postive/neg confirm response\r\n        response_status = response\r\
      \n        postamble = -1234567890\r\n        msg = (                       \
      \                  # Convert from int32 values to binary\r\n           self.int32tobytes(msg_size_array[0])\
      \ +\r\n           self.int32tobytes(msg_size_array[1]) +\r\n           self.int32tobytes(msg_size_array[2])\
      \ +\r\n           self.int32tobytes(output_flow_identifier) +\r\n          \
      \ self.int32tobytes(operation_type) + \r\n           self.int32tobytes(vcid)\
      \ +\r\n           self.int32tobytes(req_tag) +\r\n           self.int32tobytes(response_status)\
      \ +\r\n           self.int32tobytes(postamble)\r\n           )\r\n        return\
      \ msg # Return tcp msg in binary\r\n\r\n    # Build tcp message for alert indication\
      \ message\r\n    def alert_indication_msg(self, fop_identifier, vcid, alert_code):\r\
      \n        msg_size = 32 # 32 bytes default value\r\n        msg_size_array =\
      \ [(msg_size >> 64) & 0xFFFFFFFF,(msg_size >> 32) & 0xFFFFFFFF,msg_size & 0xFFFFFFFF]\
      \ # Split msg_size into 3 int32 values\r\n        output_flow_identifier = 2\
      \ # 2 for alert indication message\r\n        postamble = -1234567890\r\n  \
      \      msg = (                                         # Convert from int32\
      \ values to binary\r\n           self.int32tobytes(msg_size_array[0]) +\r\n\
      \           self.int32tobytes(msg_size_array[1]) +\r\n           self.int32tobytes(msg_size_array[2])\
      \ +\r\n           self.int32tobytes(output_flow_identifier) +\r\n          \
      \ self.int32tobytes(fop_identifier) + \r\n           self.int32tobytes(vcid)\
      \ +\r\n           self.int32tobytes(alert_code) +\r\n           self.int32tobytes(postamble)\r\
      \n           )\r\n        return msg # Return tcp msg in binary\r\n\r\n    #\
      \ Build tcp message for suspend indication message\r\n    def suspend_indication_msg(self,\
      \ fop_identifier, vcid):\r\n        msg_size = 32 # 32 bytes default value\r\
      \n        msg_size_array = [(msg_size >> 64) & 0xFFFFFFFF,(msg_size >> 32) &\
      \ 0xFFFFFFFF,msg_size & 0xFFFFFFFF] # Split msg_size into 3 int32 values\r\n\
      \        output_flow_identifier = 3 # 2 for suspend indication message\r\n \
      \       suspend_indication = 0 # default value\r\n        postamble = -1234567890\r\
      \n        msg = (                                         # Convert from int32\
      \ values to binary\r\n           self.int32tobytes(msg_size_array[0]) +\r\n\
      \           self.int32tobytes(msg_size_array[1]) +\r\n           self.int32tobytes(msg_size_array[2])\
      \ +\r\n           self.int32tobytes(output_flow_identifier) +\r\n          \
      \ self.int32tobytes(fop_identifier) + \r\n           self.int32tobytes(vcid)\
      \ +\r\n           self.int32tobytes(suspend_indication) +\r\n           self.int32tobytes(postamble)\r\
      \n           )\r\n        return msg # Return tcp msg in binary\r\n\r\n    #\
      \ Get the operation type field value for the respective directives\r\n    def\
      \ get_op_type(self, directive):\r\n        if (directive == FopDirective.INIT_AD_WITHOUT_CLCW):\r\
      \n            return 2\r\n        elif (directive == FopDirective.INIT_AD_WITH_CLCW):\r\
      \n            return 3\r\n        elif (directive == FopDirective.INIT_AD_WITH_UNLOCK):\r\
      \n            return 4\r\n        elif (directive == FopDirective.INIT_AD_WITH_SET_V_R):\r\
      \n            return 5\r\n        elif (directive == FopDirective.TERMINATE):\r\
      \n            return 6\r\n        elif (directive == FopDirective.RESUME):\r\
      \n            return 7\r\n        elif (directive == FopDirective.SET_V_S):\r\
      \n            return 8\r\n        elif (directive == FopDirective.SET_FOP_SLIDING_WINDOW):\r\
      \n            return 9\r\n        elif (directive == FopDirective.SET_T1_INITIAL):\r\
      \n            return 10\r\n        elif (directive == FopDirective.SET_TRANSMISSION_LIMIT):\r\
      \n            return 11\r\n        elif (directive == FopDirective.SET_TIMEOUT_TYPE):\r\
      \n            return 12\r\n\r\n    # Get the alert code field value for the\
      \ respective alert codes\r\n    def get_alert_code(self, code):\r\n        if\
      \ code == FopAlertCode.LIMIT:\r\n            return 1\r\n        elif code ==\
      \ FopAlertCode.LOCKOUT:\r\n            return 2\r\n        elif code == FopAlertCode.SYNCH:\r\
      \n            return 3\r\n        elif code == FopAlertCode.NN_R:\r\n      \
      \      return 4\r\n        elif code == FopAlertCode.CLCW:\r\n            return\
      \ 5\r\n        elif code == FopAlertCode.LLIF:\r\n            return 6\r\n \
      \       elif code == FopAlertCode.TERM:\r\n            return 7\r\n        elif\
      \ code == FopAlertCode.T1:\r\n            return 9\r\n        else:\r\n    \
      \        return 8 #alert not applicable\r\n            \r\n            \r\n\
      \    \r\n"
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [712, 348.0]
    rotation: 0
    state: enabled
- name: S1FopState
  id: epy_module
  parameters:
    alias: ''
    comment: ''
    source_code: "from overall_FopEvent import FopEvent\r\nfrom overall_FopAlertCode\
      \ import FopAlertCode\r\nfrom overall_FopState import FopState\r\nfrom overall_S2FopState\
      \ import S2FopState\r\nfrom overall_S3FopState import S3FopState\r\nfrom overall_S6FopState\
      \ import S6FopState\r\nfrom overall_AbstractFopState import AbstractFopState\r\
      \n\r\n# Define the actions required and the appropriate methods to call for\
      \ FOP-1 events while in FOP-1 state S1\r\nclass S1FopState(AbstractFopState):\r\
      \n    def __init__(self, engine):\r\n        super().__init__(engine)\r\n\r\n\
      \    # Registering event handlers for different FOP events\r\n    def register_handlers(self):\r\
      \n        self.event2handler = {\r\n            FopEvent.EventNumber.E1: self.ignore,\r\
      \n            FopEvent.EventNumber.E2: self.e2,\r\n            FopEvent.EventNumber.E3:\
      \ self.e3e7e15,\r\n            FopEvent.EventNumber.E4: self.e4,\r\n       \
      \     FopEvent.EventNumber.E5: self.ignore,\r\n            FopEvent.EventNumber.E6:\
      \ self.e6,\r\n            FopEvent.EventNumber.E7: self.e3e7e15,\r\n       \
      \     FopEvent.EventNumber.E101: self.e101,\r\n            FopEvent.EventNumber.E102:\
      \ self.e102,\r\n            FopEvent.EventNumber.E8: self.e8,\r\n          \
      \  FopEvent.EventNumber.E9: self.e9,\r\n            FopEvent.EventNumber.E10:\
      \ self.e10,\r\n            FopEvent.EventNumber.E11: self.e11,\r\n         \
      \   FopEvent.EventNumber.E12: self.e12,\r\n            FopEvent.EventNumber.E103:\
      \ self.e103,\r\n            FopEvent.EventNumber.E13: self.e13,\r\n        \
      \    FopEvent.EventNumber.E14: self.e14,\r\n            FopEvent.EventNumber.E15:\
      \ self.e3e7e15,\r\n            FopEvent.EventNumber.E16: self.e16e104,\r\n \
      \           FopEvent.EventNumber.E104: self.e16e104,\r\n            FopEvent.EventNumber.E17:\
      \ self.e17,\r\n            FopEvent.EventNumber.E18: self.e18,\r\n         \
      \   FopEvent.EventNumber.E19: self.e19,\r\n            FopEvent.EventNumber.E20:\
      \ self.reject,\r\n            FopEvent.EventNumber.E21: self.e21,\r\n      \
      \      FopEvent.EventNumber.E22: self.reject,\r\n            FopEvent.EventNumber.E23:\
      \ self.reject,\r\n            FopEvent.EventNumber.E24: self.reject,\r\n   \
      \         FopEvent.EventNumber.E25: self.reject,\r\n            FopEvent.EventNumber.E26:\
      \ self.reject,\r\n            FopEvent.EventNumber.E27: self.reject,\r\n   \
      \         FopEvent.EventNumber.E28: self.reject,\r\n            FopEvent.EventNumber.E29:\
      \ self.e29,\r\n            FopEvent.EventNumber.E30: self.reject,\r\n      \
      \      FopEvent.EventNumber.E35: self.reject,\r\n            FopEvent.EventNumber.E36:\
      \ self.e36,\r\n            FopEvent.EventNumber.E37: self.e37,\r\n         \
      \   FopEvent.EventNumber.E38: self.e38,\r\n            FopEvent.EventNumber.E39:\
      \ self.e39,\r\n            FopEvent.EventNumber.E40: self.reject,\r\n      \
      \      FopEvent.EventNumber.E41: self.e41,\r\n            FopEvent.EventNumber.E42:\
      \ self.e42,\r\n            FopEvent.EventNumber.E43: self.e43,\r\n         \
      \   FopEvent.EventNumber.E44: self.e44,\r\n            FopEvent.EventNumber.E45:\
      \ self.e45,\r\n            FopEvent.EventNumber.E46: self.e46,\r\n        }\r\
      \n\r\n    # Return the current state\r\n    def get_state(self):\r\n       \
      \ return FopState.S1\r\n    \r\n    # Handler functions for different events\r\
      \n    def e2(self, fop_event):\r\n        self.engine.remove_ack_frames_from_sent_queue(fop_event.get_clcw())\r\
      \n        self.engine.cancel_timer()\r\n        self.engine.look_for_frame()\r\
      \n        return self\r\n\r\n    def e3e7e15(self, fop_event):\r\n        self.engine.alert(FopAlertCode.CLCW)\r\
      \n        return S6FopState(self.engine)\r\n\r\n    def e4(self, fop_event):\r\
      \n        self.engine.alert(FopAlertCode.SYNCH)\r\n        return S6FopState(self.engine)\r\
      \n\r\n    def e6(self, fop_event):\r\n        self.engine.remove_ack_frames_from_sent_queue(fop_event.get_clcw())\r\
      \n        self.engine.look_for_frame()\r\n        return self\r\n\r\n    def\
      \ e101(self, fop_event):\r\n        self.engine.remove_ack_frames_from_sent_queue(fop_event.get_clcw())\r\
      \n        self.engine.alert(FopAlertCode.LIMIT)\r\n        return S6FopState(self.engine)\r\
      \n\r\n    def e102(self, fop_event):\r\n        self.engine.alert(FopAlertCode.LIMIT)\r\
      \n        return S6FopState(self.engine)\r\n\r\n    def e8(self, fop_event):\r\
      \n        self.engine.remove_ack_frames_from_sent_queue(fop_event.get_clcw())\r\
      \n        self.engine.initiate_ad_retransmission()\r\n        self.engine.look_for_frame()\r\
      \n        return S2FopState(self.engine)\r\n\r\n    def e9(self, fop_event):\r\
      \n        self.engine.remove_ack_frames_from_sent_queue(fop_event.get_clcw())\r\
      \n        return S3FopState(self.engine)\r\n\r\n    def e10(self, fop_event):\r\
      \n        self.engine.initiate_ad_retransmission()\r\n        self.engine.look_for_frame()\r\
      \n        return S2FopState(self.engine)\r\n\r\n    def e11(self, fop_event):\r\
      \n        return S3FopState(self.engine)\r\n\r\n    def e12(self, fop_event):\r\
      \n        return S2FopState(self.engine)\r\n\r\n    def e103(self, fop_event):\r\
      \n        return S3FopState(self.engine)\r\n\r\n    def e13(self, fop_event):\r\
      \n        self.engine.alert(FopAlertCode.NN_R)\r\n        return S6FopState(self.engine)\r\
      \n\r\n    def e14(self, fop_event):\r\n        self.engine.alert(FopAlertCode.LOCKOUT)\r\
      \n        return S6FopState(self.engine)\r\n\r\n    def e16e104(self, fop_event):\r\
      \n        self.engine.initiate_ad_retransmission()\r\n        self.engine.look_for_frame()\r\
      \n        return self\r\n\r\n    def e17(self, fop_event):\r\n        self.engine.alert(FopAlertCode.T1)\t\
      \r\n        return S6FopState(self.engine)\r\n\r\n    def e18(self, fop_event):\r\
      \n        self.engine.set_suspend_state(1)\r\n        self.engine.suspend()\r\
      \n        return S6FopState(self.engine)\r\n\r\n    def e19(self, fop_event):\r\
      \n        self.engine.add_to_wait_queue(fop_event)\r\n        self.engine.look_for_frame()\r\
      \n        return self\r\n\r\n    def e41(self, fop_event):\r\n        self.engine.set_ad_out_ready_flag(True)\r\
      \n        self.engine.look_for_frame()\r\n        return self\r\n\r\n    def\
      \ e43(self, fop_event):\r\n        self.engine.set_bc_out_ready_flag(True)\r\
      \n        return self\r\n\r\n\r\n\r\n"
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [512, 348.0]
    rotation: 0
    state: enabled
- name: S2FopState
  id: epy_module
  parameters:
    alias: ''
    comment: ''
    source_code: "from overall_FopEvent import FopEvent\r\nfrom overall_AbstractFopState\
      \ import AbstractFopState\r\nfrom overall_FopAlertCode import FopAlertCode\r\
      \nfrom overall_FopState import FopState\r\nfrom overall_S3FopState import S3FopState\r\
      \nfrom overall_S6FopState import S6FopState\r\n\r\n# Define the actions required\
      \ and the appropriate methods to call for FOP-1 events while in FOP-1 state\
      \ S2\r\nclass S2FopState(AbstractFopState):\r\n    def __init__(self, engine):\r\
      \n        super().__init__(engine)\r\n\r\n    # Registering event handlers for\
      \ different FOP events\r\n    def register_handlers(self):\r\n        self.event2handler\
      \ = {\r\n            FopEvent.EventNumber.E1: self.e1e4e5,\r\n            FopEvent.EventNumber.E2:\
      \ self.e2,\r\n            FopEvent.EventNumber.E3: self.e3e7e15,\r\n       \
      \     FopEvent.EventNumber.E4: self.e1e4e5,\r\n            FopEvent.EventNumber.E5:\
      \ self.e1e4e5,\r\n            FopEvent.EventNumber.E6: self.e6,\r\n        \
      \    FopEvent.EventNumber.E7: self.e3e7e15,\r\n            FopEvent.EventNumber.E101:\
      \ self.e101,\r\n            FopEvent.EventNumber.E102: self.e102,\r\n      \
      \      FopEvent.EventNumber.E8: self.e8,\r\n            FopEvent.EventNumber.E9:\
      \ self.e9,\r\n            FopEvent.EventNumber.E10: self.ignore,\r\n       \
      \     FopEvent.EventNumber.E11: self.e11e103,\r\n            FopEvent.EventNumber.E12:\
      \ self.ignore,\r\n            FopEvent.EventNumber.E103: self.e11e103,\r\n \
      \           FopEvent.EventNumber.E13: self.e13,\r\n            FopEvent.EventNumber.E14:\
      \ self.e14,\r\n            FopEvent.EventNumber.E15: self.e3e7e15,\r\n     \
      \       FopEvent.EventNumber.E16: self.e16e104,\r\n            FopEvent.EventNumber.E104:\
      \ self.e16e104,\r\n            FopEvent.EventNumber.E17: self.e17,\r\n     \
      \       FopEvent.EventNumber.E18: self.e18,\r\n            FopEvent.EventNumber.E19:\
      \ self.e19,\r\n            FopEvent.EventNumber.E20: self.reject,\r\n      \
      \      FopEvent.EventNumber.E21: self.e21,\r\n            FopEvent.EventNumber.E22:\
      \ self.reject,\r\n            FopEvent.EventNumber.E23: self.reject,\r\n   \
      \         FopEvent.EventNumber.E24: self.reject,\r\n            FopEvent.EventNumber.E25:\
      \ self.reject,\r\n            FopEvent.EventNumber.E26: self.reject,\r\n   \
      \         FopEvent.EventNumber.E27: self.reject,\r\n            FopEvent.EventNumber.E28:\
      \ self.reject,\r\n            FopEvent.EventNumber.E29: self.e29,\r\n      \
      \      FopEvent.EventNumber.E30: self.reject,\r\n            FopEvent.EventNumber.E35:\
      \ self.reject,\r\n            FopEvent.EventNumber.E36: self.e36,\r\n      \
      \      FopEvent.EventNumber.E37: self.e37,\r\n            FopEvent.EventNumber.E38:\
      \ self.e38,\r\n            FopEvent.EventNumber.E39: self.e39,\r\n         \
      \   FopEvent.EventNumber.E40: self.reject,\r\n            FopEvent.EventNumber.E41:\
      \ self.e41,\r\n            FopEvent.EventNumber.E42: self.e42,\r\n         \
      \   FopEvent.EventNumber.E43: self.e43,\r\n            FopEvent.EventNumber.E44:\
      \ self.e44,\r\n            FopEvent.EventNumber.E45: self.e45,\r\n         \
      \   FopEvent.EventNumber.E46: self.e46\r\n        }\r\n\r\n    # Return the\
      \ current state\r\n    def get_state(self):\r\n        return FopState.S2\r\n\
      \r\n    # Handler functions for different events\r\n    def e1e4e5(self, fop_event):\r\
      \n        self.engine.alert(FopAlertCode.SYNCH)\r\n        return S6FopState(self.engine)\r\
      \n\r\n    def e2(self, fop_event):\r\n        self.engine.remove_ack_frames_from_sent_queue(fop_event.get_clcw())\r\
      \n        self.engine.cancel_timer()\r\n        self.engine.look_for_frame()\r\
      \n        from overall_S1FopState import S1FopState\r\n        return S1FopState(self.engine)\r\
      \n\r\n    def e3e7e15(self, fop_event):\r\n        self.engine.alert(FopAlertCode.CLCW)\r\
      \n        return S6FopState(self.engine)\r\n\r\n    def e6(self, fop_event):\r\
      \n        self.engine.remove_ack_frames_from_sent_queue(fop_event.get_clcw())\r\
      \n        self.engine.look_for_frame()\r\n        from overall_S1FopState import\
      \ S1FopState\r\n        return S1FopState(self.engine)\r\n\r\n    def e101(self,\
      \ fop_event):\r\n        self.engine.remove_ack_frames_from_sent_queue(fop_event.get_clcw())\r\
      \n        self.engine.alert(FopAlertCode.LIMIT)\r\n        return S6FopState(self.engine)\r\
      \n\r\n    def e102(self, fop_event):\r\n        self.engine.alert(FopAlertCode.LIMIT)\r\
      \n        return S6FopState(self.engine)\r\n\r\n    def e8(self, fop_event):\r\
      \n        self.engine.remove_ack_frames_from_sent_queue(fop_event.get_clcw())\r\
      \n        self.engine.initiate_ad_retransmission()\r\n        self.engine.look_for_frame()\r\
      \n        return self\r\n\r\n    def e9(self, fop_event):\r\n        self.engine.remove_ack_frames_from_sent_queue(fop_event.get_clcw())\r\
      \n        return S3FopState(self.engine)\r\n\r\n    def e11e103(self, fop_event):\r\
      \n        return S3FopState(self.engine)\r\n\r\n    def e13(self, fop_event):\r\
      \n        self.engine.alert(FopAlertCode.NN_R)\r\n        return S6FopState(self.engine)\r\
      \n\r\n    def e14(self, fop_event):\r\n        self.engine.alert(FopAlertCode.LOCKOUT)\r\
      \n        return S6FopState(self.engine)\r\n\r\n    def e16e104(self, fop_event):\r\
      \n        self.engine.initiate_ad_retransmission()\r\n        self.engine.look_for_frame()\r\
      \n        return self\r\n\r\n    def e17(self, fop_event):\r\n        self.engine.alert(FopAlertCode.T1)\r\
      \n        return S6FopState(self.engine)\r\n\r\n    def e18(self, fop_event):\r\
      \n        self.engine.set_suspend_state(2)\r\n        self.engine.suspend()\r\
      \n        return S6FopState(self.engine)\r\n\r\n    def e19(self, fop_event):\r\
      \n        self.engine.add_to_wait_queue(fop_event)\r\n        self.engine.look_for_frame()\r\
      \n        return self\r\n\r\n    def e41(self, fop_event):\r\n        self.engine.set_ad_out_ready_flag(True)\r\
      \n        self.engine.look_for_frame()\r\n        return self\r\n\r\n    def\
      \ e43(self, fop_event):\r\n        self.engine.set_bc_out_ready_flag(True)\r\
      \n        return self\r\n\r\n\r\n"
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [512, 412.0]
    rotation: 0
    state: enabled
- name: S3FopState
  id: epy_module
  parameters:
    alias: ''
    comment: ''
    source_code: "from overall_FopAlertCode import FopAlertCode\r\nfrom overall_FopState\
      \ import FopState\r\nfrom overall_AbstractFopState import AbstractFopState\r\
      \nfrom overall_FopEvent import FopEvent\r\nfrom overall_S6FopState import S6FopState\r\
      \n\r\n# Define the actions required and the appropriate methods to call for\
      \ FOP-1 events while in FOP-1 state S3\r\nclass S3FopState(AbstractFopState):\r\
      \n    def __init__(self, engine):\r\n        super().__init__(engine)\r\n\r\n\
      \    # Registering event handlers for different FOP events\r\n    def register_handlers(self):\r\
      \n        self.event2handler = {\r\n            FopEvent.EventNumber.E1: self.e1e4e5,\r\
      \n            FopEvent.EventNumber.E2: self.e2,\r\n            FopEvent.EventNumber.E3:\
      \ self.e3e7e15,\r\n            FopEvent.EventNumber.E4: self.e1e4e5,\r\n   \
      \         FopEvent.EventNumber.E5: self.e1e4e5,\r\n            FopEvent.EventNumber.E6:\
      \ self.e6,\r\n            FopEvent.EventNumber.E7: self.e3e7e15,\r\n       \
      \     FopEvent.EventNumber.E101: self.e101,\r\n            FopEvent.EventNumber.E102:\
      \ self.e102,\r\n            FopEvent.EventNumber.E8: self.e8,\r\n          \
      \  FopEvent.EventNumber.E9: self.e9,\r\n            FopEvent.EventNumber.E10:\
      \ self.e10,\r\n            FopEvent.EventNumber.E11: self.ignore,\r\n      \
      \      FopEvent.EventNumber.E12: self.e12,\r\n            FopEvent.EventNumber.E103:\
      \ self.ignore,\r\n            FopEvent.EventNumber.E13: self.e13,\r\n      \
      \      FopEvent.EventNumber.E14: self.e14,\r\n            FopEvent.EventNumber.E15:\
      \ self.e3e7e15,\r\n            FopEvent.EventNumber.E16: self.ignore,\r\n  \
      \          FopEvent.EventNumber.E104: self.ignore,\r\n            FopEvent.EventNumber.E17:\
      \ self.e17,\r\n            FopEvent.EventNumber.E18: self.e18,\r\n         \
      \   FopEvent.EventNumber.E19: self.e19,\r\n            FopEvent.EventNumber.E20:\
      \ self.reject,\r\n            FopEvent.EventNumber.E21: self.e21,\r\n      \
      \      FopEvent.EventNumber.E22: self.reject,\r\n            FopEvent.EventNumber.E23:\
      \ self.reject,\r\n            FopEvent.EventNumber.E24: self.reject,\r\n   \
      \         FopEvent.EventNumber.E25: self.reject,\r\n            FopEvent.EventNumber.E26:\
      \ self.reject,\r\n            FopEvent.EventNumber.E27: self.reject,\r\n   \
      \         FopEvent.EventNumber.E28: self.reject,\r\n            FopEvent.EventNumber.E29:\
      \ self.e29,\r\n            FopEvent.EventNumber.E30: self.reject,\r\n      \
      \      FopEvent.EventNumber.E35: self.reject,\r\n            FopEvent.EventNumber.E36:\
      \ self.e36,\r\n            FopEvent.EventNumber.E37: self.e37,\r\n         \
      \   FopEvent.EventNumber.E38: self.e38,\r\n            FopEvent.EventNumber.E39:\
      \ self.e39,\r\n            FopEvent.EventNumber.E40: self.reject,\r\n      \
      \      FopEvent.EventNumber.E41: self.e41,\r\n            FopEvent.EventNumber.E42:\
      \ self.e42,\r\n            FopEvent.EventNumber.E43: self.e43,\r\n         \
      \   FopEvent.EventNumber.E44: self.e44,\r\n            FopEvent.EventNumber.E45:\
      \ self.e45,\r\n            FopEvent.EventNumber.E46: self.e46\r\n        }\r\
      \n\r\n    # Return the current state\r\n    def get_state(self):\r\n       \
      \ return FopState.S3\r\n\r\n    # Handler functions for different events\r\n\
      \    def e1e4e5(self, fop_event):\r\n        self.engine.alert(FopAlertCode.SYNCH)\r\
      \n        return S6FopState(self.engine)\r\n\r\n    def e2(self, fop_event):\r\
      \n        self.engine.remove_ack_frames_from_sent_queue(fop_event.get_clcw())\r\
      \n        self.engine.cancel_timer()\r\n        self.engine.look_for_frame()\r\
      \n        from overall_S1FopState import S1FopState\r\n        return S1FopState(self.engine)\r\
      \n\r\n    def e3e7e15(self, fop_event):\r\n        self.engine.alert(FopAlertCode.CLCW)\r\
      \n        return S6FopState(self.engine)\r\n\r\n    def e6(self, fop_event):\r\
      \n        self.engine.remove_ack_frames_from_sent_queue(fop_event.get_clcw())\r\
      \n        self.engine.look_for_frame()\r\n        from overall_S1FopState import\
      \ S1FopState\r\n        return S1FopState(self.engine)\r\n\r\n    def e101(self,\
      \ fop_event):\r\n        self.engine.remove_ack_frames_from_sent_queue(fop_event.get_clcw())\r\
      \n        self.engine.alert(FopAlertCode.LIMIT)\r\n        return S6FopState(self.engine)\r\
      \n\r\n    def e102(self, fop_event):\r\n        self.engine.alert(FopAlertCode.LIMIT)\r\
      \n        return S6FopState(self.engine)\r\n\r\n    def e8(self, fop_event):\r\
      \n        self.engine.remove_ack_frames_from_sent_queue(fop_event.get_clcw())\r\
      \n        self.engine.initiate_ad_retransmission()\r\n        self.engine.look_for_frame()\r\
      \n        from overall_S2FopState import S2FopState\r\n        return S2FopState(self.engine)\r\
      \n\r\n    def e9(self, fop_event):\r\n        self.engine.remove_ack_frames_from_sent_queue(fop_event.get_clcw())\r\
      \n        return self\r\n\r\n    def e10(self, fop_event):\r\n        self.engine.initiate_ad_retransmission()\r\
      \n        from overall_S2FopState import S2FopState\r\n        return S2FopState(self.engine)\r\
      \n\r\n    def e12(self, fop_event):\r\n        from overall_S2FopState import\
      \ S2FopState\r\n        return S2FopState(self.engine)\r\n\r\n    def e13(self,\
      \ fop_event):\r\n        self.engine.alert(FopAlertCode.NN_R)\r\n        return\
      \ S6FopState(self.engine)\r\n\r\n    def e14(self, fop_event):\r\n        self.engine.alert(FopAlertCode.LOCKOUT)\r\
      \n        return S6FopState(self.engine)\r\n\r\n    def e17(self, fop_event):\r\
      \n        self.engine.alert(FopAlertCode.T1)\r\n        return S6FopState(self.engine)\r\
      \n\r\n    def e18(self, fop_event):\r\n        self.engine.set_suspend_state(3)\r\
      \n        self.engine.suspend()\r\n        return S6FopState(self.engine)\r\n\
      \r\n    def e19(self, fop_event):\r\n        self.engine.add_to_wait_queue(fop_event)\r\
      \n        return self\r\n\r\n    def e41(self, fop_event):\r\n        self.engine.set_ad_out_ready_flag(True)\r\
      \n        return self\r\n\r\n    def e43(self, fop_event):\r\n        self.engine.set_bc_out_ready_flag(True)\r\
      \n        return self\r\n\r\n\r\n"
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [512, 476.0]
    rotation: 0
    state: enabled
- name: S4FopState
  id: epy_module
  parameters:
    alias: ''
    comment: ''
    source_code: "from overall_FopAlertCode import FopAlertCode\r\nfrom overall_FopState\
      \ import FopState\r\nfrom overall_AbstractFopState import AbstractFopState\r\
      \nfrom overall_FopEvent import FopEvent\r\nfrom overall_S6FopState import S6FopState\r\
      \nfrom overall_S1FopState import S1FopState\r\n\r\n# Define the actions required\
      \ and the appropriate methods to call for FOP-1 events while in FOP-1 state\
      \ S4\r\nclass S4FopState(AbstractFopState):\r\n    def __init__(self, engine):\r\
      \n        super().__init__(engine)\r\n\r\n    # Registering event handlers for\
      \ different FOP events\r\n    def register_handlers(self):\r\n        self.event2handler\
      \ = {\r\n            FopEvent.EventNumber.E1: self.e1,\r\n            FopEvent.EventNumber.E3:\
      \ self.e3e15,\r\n            FopEvent.EventNumber.E4: self.e4,\r\n         \
      \   FopEvent.EventNumber.E13: self.e13,\r\n            FopEvent.EventNumber.E14:\
      \ self.e14,\r\n            FopEvent.EventNumber.E15: self.e3e15,\r\n       \
      \     FopEvent.EventNumber.E16: self.e16e17,\r\n            FopEvent.EventNumber.E104:\
      \ self.e104e18,\r\n            FopEvent.EventNumber.E17: self.e16e17,\r\n  \
      \          FopEvent.EventNumber.E18: self.e104e18,\r\n            FopEvent.EventNumber.E19:\
      \ self.reject,\r\n            FopEvent.EventNumber.E20: self.reject,\r\n   \
      \         FopEvent.EventNumber.E21: self.e21,\r\n            FopEvent.EventNumber.E22:\
      \ self.reject,\r\n            FopEvent.EventNumber.E23: self.reject,\r\n   \
      \         FopEvent.EventNumber.E24: self.reject,\r\n            FopEvent.EventNumber.E25:\
      \ self.reject,\r\n            FopEvent.EventNumber.E26: self.reject,\r\n   \
      \         FopEvent.EventNumber.E27: self.reject,\r\n            FopEvent.EventNumber.E28:\
      \ self.reject,\r\n            FopEvent.EventNumber.E29: self.e29,\r\n      \
      \      FopEvent.EventNumber.E30: self.reject,\r\n            FopEvent.EventNumber.E35:\
      \ self.reject,\r\n            FopEvent.EventNumber.E36: self.e36,\r\n      \
      \      FopEvent.EventNumber.E37: self.e37,\r\n            FopEvent.EventNumber.E38:\
      \ self.e38,\r\n            FopEvent.EventNumber.E39: self.e39,\r\n         \
      \   FopEvent.EventNumber.E40: self.reject,\r\n            FopEvent.EventNumber.E41:\
      \ self.e41,\r\n            FopEvent.EventNumber.E42: self.e42,\r\n         \
      \   FopEvent.EventNumber.E43: self.e43,\r\n            FopEvent.EventNumber.E44:\
      \ self.e44,\r\n            FopEvent.EventNumber.E45: self.e45,\r\n         \
      \   FopEvent.EventNumber.E46: self.e46\r\n        }\r\n\r\n    # Return the\
      \ current state\r\n    def get_state(self):\r\n        return FopState.S4\r\n\
      \    \r\n    # Handler functions for different events\r\n    def e1(self, fop_event):\r\
      \n        self.engine.confirm_pending_init_ad_with_clcw(fop_event.get_clcw())\r\
      \n        self.engine.cancel_timer()\r\n        return S1FopState(self.engine)\r\
      \n\r\n    def e3e15(self, fop_event):\r\n        self.engine.alert(FopAlertCode.CLCW)\r\
      \n        return S6FopState(self.engine)\r\n\r\n    def e4(self, fop_event):\r\
      \n        self.engine.alert(FopAlertCode.SYNCH)\r\n        return S6FopState(self.engine)\r\
      \n\r\n    def e13(self, fop_event):\r\n        self.engine.alert(FopAlertCode.NN_R)\r\
      \n        return S6FopState(self.engine)\r\n\r\n    def e14(self, fop_event):\r\
      \n        self.engine.alert(FopAlertCode.LOCKOUT)\r\n        return S6FopState(self.engine)\r\
      \n\r\n    def e16e17(self, fop_event):\r\n        self.engine.alert(FopAlertCode.T1)\r\
      \n        return S6FopState(self.engine)\r\n\r\n    def e104e18(self, fop_event):\r\
      \n        self.engine.set_suspend_state(4)\r\n        self.engine.suspend()\r\
      \n        return S6FopState(self.engine)\r\n\r\n    def e41(self, fop_event):\r\
      \n        self.engine.set_ad_out_ready_flag(True)\r\n        return self\r\n\
      \r\n    def e43(self, fop_event):\r\n        self.engine.set_bc_out_ready_flag(True)\r\
      \n        return self\r\n\r\n"
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [512, 540.0]
    rotation: 0
    state: enabled
- name: S5FopState
  id: epy_module
  parameters:
    alias: ''
    comment: ''
    source_code: "from overall_FopAlertCode import FopAlertCode\r\nfrom overall_FopState\
      \ import FopState\r\nfrom overall_AbstractFopState import AbstractFopState\r\
      \nfrom overall_FopEvent import FopEvent\r\nfrom overall_S6FopState import S6FopState\r\
      \nfrom overall_S1FopState import S1FopState\r\n\r\n# Define the actions required\
      \ and the appropriate methods to call for FOP-1 events while in FOP-1 state\
      \ S5\r\nclass S5FopState(AbstractFopState):\r\n    def __init__(self, engine):\r\
      \n        super().__init__(engine)\r\n\r\n    # Registering event handlers for\
      \ different FOP events\r\n    def register_handlers(self):\r\n        self.event2handler\
      \ = {\r\n            FopEvent.EventNumber.E1: self.e1,\r\n            FopEvent.EventNumber.E3:\
      \ self.e3e15,\r\n            FopEvent.EventNumber.E4: self.ignore,\r\n     \
      \       FopEvent.EventNumber.E13: self.ignore,\r\n            FopEvent.EventNumber.E14:\
      \ self.ignore,\r\n            FopEvent.EventNumber.E15: self.e3e15,\r\n    \
      \        FopEvent.EventNumber.E16: self.e16e104,\r\n            FopEvent.EventNumber.E104:\
      \ self.e16e104,\r\n            FopEvent.EventNumber.E17: self.e17e18,\r\n  \
      \          FopEvent.EventNumber.E18: self.e17e18,\r\n            FopEvent.EventNumber.E19:\
      \ self.reject,\r\n            FopEvent.EventNumber.E20: self.reject,\r\n   \
      \         FopEvent.EventNumber.E21: self.e21,\r\n            FopEvent.EventNumber.E22:\
      \ self.reject,\r\n            FopEvent.EventNumber.E23: self.reject,\r\n   \
      \         FopEvent.EventNumber.E24: self.reject,\r\n            FopEvent.EventNumber.E25:\
      \ self.reject,\r\n            FopEvent.EventNumber.E26: self.reject,\r\n   \
      \         FopEvent.EventNumber.E27: self.reject,\r\n            FopEvent.EventNumber.E28:\
      \ self.reject,\r\n            FopEvent.EventNumber.E29: self.e29,\r\n      \
      \      FopEvent.EventNumber.E30: self.reject,\r\n            FopEvent.EventNumber.E35:\
      \ self.reject,\r\n            FopEvent.EventNumber.E36: self.e36,\r\n      \
      \      FopEvent.EventNumber.E37: self.e37,\r\n            FopEvent.EventNumber.E38:\
      \ self.e38,\r\n            FopEvent.EventNumber.E39: self.e39,\r\n         \
      \   FopEvent.EventNumber.E40: self.reject,\r\n            FopEvent.EventNumber.E41:\
      \ self.e41,\r\n            FopEvent.EventNumber.E42: self.e42,\r\n         \
      \   FopEvent.EventNumber.E43: self.e43,\r\n            FopEvent.EventNumber.E44:\
      \ self.e44,\r\n            FopEvent.EventNumber.E45: self.e45,\r\n         \
      \   FopEvent.EventNumber.E46: self.e46\r\n        }\r\n\r\n    # Return the\
      \ current state\r\n    def get_state(self):\r\n        return FopState.S5\r\n\
      \r\n    # Handler functions for different events\r\n    def e1(self, fop_event):\r\
      \n        self.engine.confirm_pending_init_ad_with_bc_frame()\r\n        self.engine.release_bc_frame()\r\
      \n        self.engine.cancel_timer()\r\n        return S1FopState(self.engine)\r\
      \n\r\n    def e3e15(self, fop_event):\r\n        self.engine.alert(FopAlertCode.CLCW)\r\
      \n        return S6FopState(self.engine)\r\n\r\n    def e16e104(self, fop_event):\r\
      \n        self.engine.initiate_bc_retransmission()\r\n        self.engine.look_for_directive()\r\
      \n        return self\r\n\r\n    def e17e18(self, fop_event):\r\n        self.engine.alert(FopAlertCode.T1)\r\
      \n        return S6FopState(self.engine)\r\n\r\n    def e41(self, fop_event):\r\
      \n        self.engine.set_ad_out_ready_flag(True)\r\n        return self\r\n\
      \r\n    def e43(self, fop_event):\r\n        self.engine.set_bc_out_ready_flag(True)\r\
      \n        self.engine.look_for_directive()\r\n        return self\r\n\r\n\r\n"
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [512, 604.0]
    rotation: 0
    state: enabled
- name: S6FopState
  id: epy_module
  parameters:
    alias: ''
    comment: ''
    source_code: "\r\nfrom overall_FopState import FopState\r\nfrom overall_FopEvent\
      \ import FopEvent\r\nfrom overall_AbstractFopState import AbstractFopState\r\
      \n\r\n# Define the actions required and the appropriate methods to call for\
      \ FOP-1 events while in FOP-1 state S6\r\nclass S6FopState(AbstractFopState):\r\
      \n    def __init__(self, engine):\r\n        super().__init__(engine)\r\n\r\n\
      \    # Registering event handlers for different FOP events\r\n    def register_handlers(self):\r\
      \n        self.event2handler = {\r\n            FopEvent.EventNumber.E1: self.ignore,\r\
      \n            FopEvent.EventNumber.E2: self.ignore,\r\n            FopEvent.EventNumber.E3:\
      \ self.ignore,\r\n            FopEvent.EventNumber.E4: self.ignore,\r\n    \
      \        FopEvent.EventNumber.E5: self.ignore,\r\n            FopEvent.EventNumber.E6:\
      \ self.ignore,\r\n            FopEvent.EventNumber.E7: self.ignore,\r\n    \
      \        FopEvent.EventNumber.E101: self.ignore,\r\n            FopEvent.EventNumber.E102:\
      \ self.ignore,\r\n            FopEvent.EventNumber.E8: self.ignore,\r\n    \
      \        FopEvent.EventNumber.E9: self.ignore,\r\n            FopEvent.EventNumber.E10:\
      \ self.ignore,\r\n            FopEvent.EventNumber.E11: self.ignore,\r\n   \
      \         FopEvent.EventNumber.E12: self.ignore,\r\n            FopEvent.EventNumber.E103:\
      \ self.ignore,\r\n            FopEvent.EventNumber.E13: self.ignore,\r\n   \
      \         FopEvent.EventNumber.E14: self.ignore,\r\n            FopEvent.EventNumber.E15:\
      \ self.ignore,\r\n            FopEvent.EventNumber.E19: self.reject,\r\n   \
      \         FopEvent.EventNumber.E20: self.reject,\r\n            FopEvent.EventNumber.E21:\
      \ self.e21,\r\n            FopEvent.EventNumber.E22: self.reject,\r\n      \
      \      FopEvent.EventNumber.E23: self.e23,\r\n            FopEvent.EventNumber.E24:\
      \ self.e24,\r\n            FopEvent.EventNumber.E25: self.e25,\r\n         \
      \   FopEvent.EventNumber.E26: self.reject,\r\n            FopEvent.EventNumber.E27:\
      \ self.e27,\r\n            FopEvent.EventNumber.E28: self.reject,\r\n      \
      \      FopEvent.EventNumber.E29: self.e29,\r\n            FopEvent.EventNumber.E30:\
      \ self.reject,\r\n            FopEvent.EventNumber.E31: self.e31,\r\n      \
      \      FopEvent.EventNumber.E32: self.e32,\r\n            FopEvent.EventNumber.E33:\
      \ self.e33,\r\n            FopEvent.EventNumber.E34: self.e34,\r\n         \
      \   FopEvent.EventNumber.E35: self.e35,\r\n            FopEvent.EventNumber.E36:\
      \ self.e36,\r\n            FopEvent.EventNumber.E37: self.e37,\r\n         \
      \   FopEvent.EventNumber.E38: self.e38,\r\n            FopEvent.EventNumber.E39:\
      \ self.e39,\r\n            FopEvent.EventNumber.E40: self.reject,\r\n      \
      \      FopEvent.EventNumber.E41: self.e41,\r\n            FopEvent.EventNumber.E42:\
      \ self.e42,\r\n            FopEvent.EventNumber.E43: self.e43,\r\n         \
      \   FopEvent.EventNumber.E44: self.e44,\r\n            FopEvent.EventNumber.E45:\
      \ self.e45,\r\n            FopEvent.EventNumber.E46: self.e46\r\n        }\r\
      \n\r\n    # Return the current state\r\n    def get_state(self):\r\n       \
      \ return FopState.S6\r\n\r\n    # Handler functions for different events\r\n\
      \    def e23(self, fop_event):\r\n        self.engine.accept_directive(fop_event.get_directive_tag(),\
      \ fop_event.get_directive_id(), fop_event.get_directive_qualifier())\r\n   \
      \     self.engine.initialise()\r\n        self.engine.confirm_directive(fop_event.get_directive_tag(),\
      \ fop_event.get_directive_id(), fop_event.get_directive_qualifier())\r\n   \
      \     from overall_S1FopState import S1FopState\r\n        return S1FopState(self.engine)\r\
      \n\r\n    def e24(self, fop_event):\r\n        self.engine.accept_directive(fop_event.get_directive_tag(),\
      \ fop_event.get_directive_id(), fop_event.get_directive_qualifier())\r\n   \
      \     self.engine.register_pending_init_ad(\r\n            fop_event.get_directive_tag(),\
      \ fop_event.get_directive_id(), fop_event.get_directive_qualifier())\r\n   \
      \     self.engine.initialise()\r\n        self.engine.restart_timer()\r\n  \
      \      from overall_S4FopState import S4FopState\r\n        return S4FopState(self.engine)\r\
      \n\r\n    def e25(self, fop_event):\r\n        self.engine.accept_directive(fop_event.get_directive_tag(),\
      \ fop_event.get_directive_id(), fop_event.get_directive_qualifier())\r\n   \
      \     self.engine.register_pending_init_ad(\r\n            fop_event.get_directive_tag(),\
      \ fop_event.get_directive_id(), fop_event.get_directive_qualifier())\r\n   \
      \     self.engine.initialise()\r\n        self.engine.transmit_type_bc_frame_unlock(fop_event.get_directive_tag())\r\
      \n        from overall_S5FopState import S5FopState\r\n        return S5FopState(self.engine)\r\
      \n\r\n    def e27(self, fop_event):\r\n        self.engine.accept_directive(fop_event.get_directive_tag(),\
      \ fop_event.get_directive_id(), fop_event.get_directive_qualifier())\r\n   \
      \     self.engine.register_pending_init_ad(\r\n            fop_event.get_directive_tag(),\
      \ fop_event.get_directive_id(), fop_event.get_directive_qualifier())\r\n   \
      \     self.engine.initialise()\r\n        self.engine.prepare_for_set_vr(fop_event.get_directive_qualifier())\r\
      \n        self.engine.transmit_type_bc_frame_set_vr(\r\n            fop_event.get_directive_tag(),\
      \ fop_event.get_directive_qualifier())\r\n        from overall_S5FopState import\
      \ S5FopState\r\n        return S5FopState(self.engine)\r\n\r\n    def e29(self,\
      \ fop_event):\r\n        self.engine.accept_directive(fop_event.get_directive_tag(),\
      \ fop_event.get_directive_id(), fop_event.get_directive_qualifier())\r\n   \
      \     self.engine.confirm_directive(fop_event.get_directive_tag(), fop_event.get_directive_id(),\
      \ fop_event.get_directive_qualifier())\r\n        return self\r\n\r\n    def\
      \ e31(self, fop_event):\r\n        self.engine.accept_directive(fop_event.get_directive_tag(),\
      \ fop_event.get_directive_id(), fop_event.get_directive_qualifier())\r\n   \
      \     self.engine.resume()\r\n        self.engine.confirm_directive(fop_event.get_directive_tag(),\
      \ fop_event.get_directive_id(), fop_event.get_directive_qualifier())\r\n   \
      \     from overall_S1FopState import S1FopState\r\n        return S1FopState(self.engine)\r\
      \n\r\n    def e32(self, fop_event):\r\n        self.engine.accept_directive(fop_event.get_directive_tag(),\
      \ fop_event.get_directive_id(), fop_event.get_directive_qualifier())\r\n   \
      \     self.engine.resume()\r\n        self.engine.confirm_directive(fop_event.get_directive_tag(),\
      \ fop_event.get_directive_id(), fop_event.get_directive_qualifier())\r\n   \
      \     from overall_S2FopState import S2FopState\r\n        return S2FopState(self.engine)\r\
      \n\r\n    def e33(self, fop_event):\r\n        self.engine.accept_directive(fop_event.get_directive_tag(),\
      \ fop_event.get_directive_id(), fop_event.get_directive_qualifier())\r\n   \
      \     self.engine.resume()\r\n        self.engine.confirm_directive(fop_event.get_directive_tag(),\
      \ fop_event.get_directive_id(), fop_event.get_directive_qualifier())\r\n   \
      \     from overall_S3FopState import S3FopState\r\n        return S3FopState(self.engine)\r\
      \n\r\n    def e34(self, fop_event):\r\n        self.engine.accept_directive(fop_event.get_directive_tag(),\
      \ fop_event.get_directive_id(), fop_event.get_directive_qualifier())\r\n   \
      \     self.engine.resume()\r\n        self.engine.confirm_directive(fop_event.get_directive_tag(),\
      \ fop_event.get_directive_id(), fop_event.get_directive_qualifier())\r\n   \
      \     from overall_S4FopState import S4FopState\r\n        return S4FopState(self.engine)\r\
      \n\r\n    def e35(self, fop_event):\r\n        if fop_event.get_suspend_state()\
      \ == 0:\r\n            self.engine.accept_directive(fop_event.get_directive_tag(),\
      \ fop_event.get_directive_id(), fop_event.get_directive_qualifier())\r\n   \
      \         self.engine.set_vs(fop_event.get_directive_qualifier())\r\n      \
      \      self.engine.confirm_directive(fop_event.get_directive_tag(), fop_event.get_directive_id(),\
      \ fop_event.get_directive_qualifier())\r\n        else:\r\n            self.engine.reject_directive(fop_event.get_directive_tag(),\
      \ fop_event.get_directive_id(), fop_event.get_directive_qualifier())\r\n   \
      \     return self\r\n\r\n    def e41(self, fop_event):\r\n        self.engine.set_ad_out_ready_flag(True)\r\
      \n        return self\r\n\r\n    def e43(self, fop_event):\r\n        self.engine.set_bc_out_ready_flag(True)\r\
      \n        return self\r\n\r\n"
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [512, 668.0]
    rotation: 0
    state: enabled
- name: TcSenderVirtualChannel
  id: epy_module
  parameters:
    alias: ''
    comment: ''
    source_code: "from typing import List, Callable, Optional\r\nfrom overall_TcTransferFrameBuilder\
      \ import TcTransferFrameBuilder\r\nfrom overall_TcTransferFrame import TcTransferFrame\r\
      \nfrom overall_TransferFrameCollector import TransferFrameCollector\r\nfrom\
      \ overall_VirtualChannelAccessMode import VirtualChannelAccessMode\r\nimport\
      \ threading\r\nimport multiprocessing\r\n\r\n# Multi-thread increment, decrement,\
      \ get value of a shared integer\r\nclass AtomicLong:\r\n    def __init__(self,\
      \ value=0):\r\n        self._value = value\r\n        self._lock = threading.Lock()\r\
      \n\r\n    def increment_and_get(self):\r\n        with self._lock:\r\n     \
      \       self._value += 1\r\n            return self._value\r\n\r\n    def decrement_and_get(self):\r\
      \n        with self._lock:\r\n            self._value -= 1\r\n            return\
      \ self._value\r\n\r\n    def get(self):\r\n        with self._lock:\r\n    \
      \        return self._value\r\n\r\n# TC Virtual Channel that store related parameters\
      \ eg frame sequence number and define methods to create AD/BD/BC frames \r\n\
      # using TcTransferFrameBuilder and store them in BcFrameCollector/ TransferFrameCollector\r\
      \nclass TcSenderVirtualChannel():\r\n    def __init__(\r\n        self,\r\n\
      \        spacecraft_id: int,\r\n        virtual_channel_id: int,\r\n       \
      \ mode: VirtualChannelAccessMode,\r\n        fecf_present: bool,\r\n       \
      \ segmented: bool,\r\n        sec_header_length: int = 0,\r\n        sec_trailer_length:\
      \ int = 0,\r\n        sec_header_supplier: Optional[Callable[[], bytes]] = None,\r\
      \n        sec_trailer_supplier: Optional[Callable[[], bytes]] = None,\r\n  \
      \  ):\r\n        self.listeners: List[TransferFrameCollector] = [] # List of\
      \ TransferFrameCollectors storing Tc transfer frames to be sent\r\n        self.spacecraft_id\
      \ = spacecraft_id\r\n        self.virtual_channel_id = virtual_channel_id\r\n\
      \        self.mode = mode\r\n        self.fecf_present = fecf_present\r\n  \
      \      self.virtual_channel_frame_counter = multiprocessing.Value('i', 0) \r\
      \n\r\n        self.emitted_frames = AtomicLong(0)\r\n        self.segmented\
      \ = segmented\r\n        self.map_id = None\r\n\r\n        if mode == VirtualChannelAccessMode.BITSTREAM:\r\
      \n            raise ValueError(\r\n                f\"Virtual channel {virtual_channel_id}\
      \ does not support access mode {mode}\"\r\n            )\r\n        self.sec_header_supplier\
      \ = sec_header_supplier\r\n        self.sec_trailer_supplier = sec_trailer_supplier\r\
      \n        self.sec_header_length = max(sec_header_length, 0)\r\n        self.sec_trailer_length\
      \ = max(sec_trailer_length, 0)\r\n        if sec_header_length > 0 and sec_header_supplier\
      \ is None:\r\n            raise ValueError(\r\n                \"Security header\
      \ length specified, but no security header supplier provided\"\r\n         \
      \   )\r\n        if sec_trailer_length > 0 and sec_trailer_supplier is None:\r\
      \n            raise ValueError(\r\n                \"Security trailer length\
      \ specified, but no security trailer supplier provided\"\r\n            )\r\n\
      \r\n    # Return whether security is used\r\n    def is_secured(self) -> bool:\r\
      \n        return self.sec_header_length > 0 or self.sec_trailer_length > 0\r\
      \n\r\n    # Return whether segmentation is enabled\r\n    def is_segmented(self)\
      \ -> bool:\r\n        return self.segmented\r\n\r\n    # Return map id\r\n \
      \   def get_map_id(self) -> int:\r\n        return self.map_id\r\n\r\n    #\
      \ Set map id\r\n    def set_map_id(self, map_id: int) -> None:\r\n        self.map_id\
      \ = map_id\r\n\r\n    # Return whether it is ad transmission\r\n    def is_ad_mode(self)\
      \ -> bool:\r\n        return self.ad_mode\r\n\r\n    # Set whether it is ad\
      \ transmission\r\n    def set_ad_mode(self, ad_mode: bool) -> None:\r\n    \
      \    self.ad_mode = ad_mode\r\n\r\n    # Build a BC unlock frame and save in\
      \ BcFrameCollector\r\n    def dispatch_unlock(self,req_tag: int) -> None:\r\n\
      \        builder = TcTransferFrameBuilder(self.is_fecf_present())\r\n      \
      \  tc = (\r\n            builder\r\n            .set_spacecraft_id(self.get_spacecraft_id())\r\
      \n            .set_virtual_channel_id(self.get_virtual_channel_id())\r\n   \
      \         .set_frame_sequence_number(0)\r\n            .set_bypass_flag(True)\r\
      \n            .set_control_command_flag(True)\r\n            .set_unlock_control_command()\r\
      \n            .set_req_tag(req_tag)\r\n            .build()\r\n        )\r\n\
      \        self.notify_transfer_frame_generated(tc, 0)\r\n\r\n    # Build a BC\
      \ set v(r) frame and save in BcFrameCollector\r\n    def dispatch_set_vr(self,\
      \ frame_number: int, req_tag: int) -> None:\r\n        builder = TcTransferFrameBuilder(self.is_fecf_present())\r\
      \n        tc = (\r\n            builder\r\n            .set_spacecraft_id(self.get_spacecraft_id())\r\
      \n            .set_virtual_channel_id(self.get_virtual_channel_id())\r\n   \
      \         .set_frame_sequence_number(0)\r\n            .set_bypass_flag(True)\r\
      \n            .set_control_command_flag(True)\r\n            .set_set_vr_control_command(frame_number)\r\
      \n            .set_req_tag(req_tag)\r\n            .build()\r\n        )\r\n\
      \        self.notify_transfer_frame_generated(tc, 0)\r\n\r\n    # Build tc transfer\
      \ frames from byte data (tc packet/segment)\r\n    def dispatch_data(self, user_data,\
      \ req_tag, operation_tag):\r\n        return self.dispatch_data_internal(self.is_ad_mode(),\
      \ self.get_map_id(), user_data, req_tag, operation_tag)\r\n\r\n    # Build tc\
      \ transfer frames from byte data (tc packet/segment) internal function\r\n \
      \   def dispatch_data_internal(self, ad_mode, map_id, data, req_tag, operation_tag,\
      \ is_packet):\r\n        if self.get_mode() != VirtualChannelAccessMode.DATA:\r\
      \n            raise RuntimeError(\"Virtual channel {} access mode set to mode\
      \ {}, but requested User Data access\".format(self.get_virtual_channel_id(),\
      \ self.get_mode()))\r\n\r\n        max_data_per_frame = self.get_max_user_data_length()\r\
      \n        # if data length is small enough (no need segmentation), build a tc\
      \ transfer frame and store in TransferFrameCollector\r\n        if max_data_per_frame\
      \ >= len(data):\r\n            sec_header = self.sec_header_supplier() if self.sec_header_supplier\
      \ else b''\r\n            sec_trailer = self.sec_trailer_supplier() if self.sec_trailer_supplier\
      \ else b''\r\n            builder = TcTransferFrameBuilder(self.is_fecf_present())\r\
      \n            # Set transfer frame header variables\r\n            current_frame\
      \ =  builder \\\r\n                .set_spacecraft_id(self.get_spacecraft_id())\
      \ \\\r\n                .set_virtual_channel_id(self.get_virtual_channel_id())\
      \ \\\r\n                .set_frame_sequence_number(self.increment_virtual_channel_frame_counter(256)\
      \ if ad_mode else 0) \\\r\n                .set_bypass_flag(not ad_mode) \\\r\
      \n                .set_control_command_flag(False) \\\r\n                .set_security(sec_header,\
      \ sec_trailer) \\\r\n                .set_req_tag(req_tag) \\\r\n          \
      \      .set_operation_tag(operation_tag)\r\n            if self.is_segmented()\
      \ and is_packet: # If segmentation is enabled and data is packet (not segment)\
      \ then add segment header\r\n                current_frame.set_segment(TcTransferFrame.SequenceFlagType.NO_SEGMENT,\
      \ map_id) # Set sequence flag to no segmentation\r\n            current_frame.add_data(data)\
      \ # Add the transfer frame user data\r\n            to_send = current_frame.build()\
      \ # Build transfer frame\r\n            self.notify_transfer_frame_generated(to_send,\
      \ 0) # Store frame in TransferFrameCollector\r\n        # Data length too long,\
      \ segmentation needed\r\n        else:\r\n            chunks = len(data) //\
      \ max_data_per_frame + (1 if len(data) % max_data_per_frame > 0 else 0)  # No\
      \ of tc transfer frames needed\r\n            # Build tc transfer frame for\
      \ each segment of data\r\n            for cki in range(chunks): \r\n       \
      \         sec_header = self.sec_header_supplier() if self.sec_header_supplier\
      \ else b''\r\n                sec_trailer = self.sec_trailer_supplier() if self.sec_trailer_supplier\
      \ else b''\r\n\r\n                builder = TcTransferFrameBuilder(self.is_fecf_present())\r\
      \n                # Set transfer frame header variables\r\n                current_frame\
      \ =  builder \\\r\n                    .set_spacecraft_id(self.get_spacecraft_id())\
      \ \\\r\n                    .set_virtual_channel_id(self.get_virtual_channel_id())\
      \ \\\r\n                    .set_frame_sequence_number(self.increment_virtual_channel_frame_counter(256)\
      \ if ad_mode else 0) \\\r\n                    .set_bypass_flag(not ad_mode)\
      \ \\\r\n                    .set_control_command_flag(False) \\\r\n        \
      \            .set_security(sec_header, sec_trailer) \\\r\n                 \
      \   .set_req_tag(req_tag) \\\r\n                    .set_operation_tag(operation_tag)\r\
      \n\r\n                if self.is_segmented(): # If segmentation is enabled,\
      \ add segment header\r\n                    if cki == 0:\r\n               \
      \         current_frame.set_segment(TcTransferFrame.SequenceFlagType.FIRST,\
      \ map_id) # Set sequence flag to first if it is the first segment\r\n      \
      \              elif cki == chunks - 1:\r\n                        current_frame.set_segment(TcTransferFrame.SequenceFlagType.LAST,\
      \ map_id) # Set sequence flag to last if it is the last segment\r\n        \
      \            else:\r\n                        current_frame.set_segment(TcTransferFrame.SequenceFlagType.CONTINUE,\
      \ map_id) # Set sequence flag to continue for all middle segments \r\n\r\n \
      \               curr_offset = cki * max_data_per_frame\r\n                current_frame.add_data(data[curr_offset:\
      \ curr_offset + max_data_per_frame]) # Add the transfer frame user data \r\n\
      \                to_send = current_frame.build() # Build transfer frame\r\n\
      \                self.notify_transfer_frame_generated(to_send, len(data) - curr_offset)\
      \ # Store frame in TransferFrameCollector\r\n\r\n        return 0\r\n\r\n  \
      \  # Return spacecraft id\r\n    def get_spacecraft_id(self) -> int:\r\n   \
      \     return self.spacecraft_id\r\n\r\n    # Return virtual channel id\r\n \
      \   def get_virtual_channel_id(self) -> int:\r\n        return self.virtual_channel_id\r\
      \n\r\n    # Return virtual channel access mode \r\n    def get_mode(self) ->\
      \ VirtualChannelAccessMode:\r\n        return self.mode\r\n\r\n    # Return\
      \ whether fecf present in transfer frames\r\n    def is_fecf_present(self) ->\
      \ bool:\r\n        return self.fecf_present\r\n\r\n    # Return next virtual\
      \ channel frame counter\r\n    def get_next_virtual_channel_frame_counter(self)\
      \ -> int:\r\n        return self.virtual_channel_frame_counter.value\r\n\r\n\
      \    # Set virtual channel frame counter\r\n    def set_virtual_channel_frame_counter(self,\
      \ number: int) -> None:\r\n        self.virtual_channel_frame_counter.value\
      \ = number\r\n\r\n    # Increment virtual channel frame counter by 1\r\n   \
      \ def increment_virtual_channel_frame_counter(self, modulus: int) -> int:\r\n\
      \        current_counter = self.virtual_channel_frame_counter.value % modulus\r\
      \n        self.virtual_channel_frame_counter.value = 1 if current_counter ==\
      \ 0 else current_counter + 1\r\n        return current_counter\r\n\r\n    #\
      \ Add a listener: TransferFrameCollector/BcFrameCollector (that will store the\
      \ transfer frames that are built)\r\n    def register(self, listener) -> None:\r\
      \n        self.listeners.append(listener)\r\n\r\n    # Remove a listener: TransferFrameCollector/BcFrameCollector\
      \ (that will store the transfer frames that are built)\r\n    def deregister(self,\
      \ listener) -> None:\r\n        self.listeners.remove(listener)\r\n\r\n    #\
      \ Request to store transfer frames to all registered listeners (i.e. TransferFrameCollector/BcFrameCollector)\
      \ \r\n    # TransferFrameCollector will accept and store AD/BD frames only,\
      \ BcFrameCollector will accept and store BC frames only\r\n    def notify_transfer_frame_generated(\r\
      \n        self, frame: TcTransferFrame, current_buffered_data: int\r\n    )\
      \ -> None:\r\n        self.emitted_frames.increment_and_get()\r\n        for\
      \ listener in self.listeners:\r\n            listener.transfer_frame_generated(self,\
      \ frame, current_buffered_data)\r\n\r\n    # Return whether there is frame pending\r\
      \n    def is_pending_frame_present(self) -> bool:\r\n        return self.current_frame\
      \ is not None\r\n\r\n    # Return remaining free user length\r\n    def get_remaining_free_space(self)\
      \ -> int:\r\n        return (\r\n            self.current_frame.get_free_user_data_length()\r\
      \n            if self.current_frame\r\n            else self.get_max_user_data_length()\r\
      \n        )\r\n\r\n    # Reset the current frame\r\n    def reset(self) -> None:\r\
      \n        self.current_frame = None\r\n\r\n    # Return total number of transfer\
      \ frames that are built\r\n    def get_nb_of_emitted_frames(self) -> int:\r\n\
      \        return self.emitted_frames.get()\r\n    \r\n    # Return max user data\
      \ length\r\n    def get_max_user_data_length(self):\r\n        builder = TcTransferFrameBuilder(self.is_fecf_present())\r\
      \n        return builder.compute_max_user_data_length() \\\r\n            -\
      \ (1 if self.is_segmented() else 0) \\\r\n            - self.sec_header_length\
      \ \\\r\n            - self.sec_trailer_length\r\n\r\n"
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [304, 604.0]
    rotation: 0
    state: true
- name: TcTransferFrame
  id: epy_module
  parameters:
    alias: ''
    comment: ''
    source_code: "import struct\r\nimport enum\r\nimport copy\r\n\r\n\r\n# This class\
      \ is used to decode and manipulate a TC transfer frame, compliant to CCSDS 232.0-B-3.\
      \ It includes also support\r\n# for the security protocol, as defined by the\
      \ same standard.\r\nclass TcTransferFrame:\r\n\r\n    # The type of TC frame.\r\
      \n    class FrameType(enum.Enum):\r\n        AD = 0 # Sequence-controlled: bypass\
      \ flag set to 0, control command flag set to 0\r\n        RESERVED = 1 # Reserved\
      \ for future use: bypass flag set to 0, control command flag set to 1\r\n  \
      \      BD = 2 # Expedited: bypass flag set to 1, control command flag set to\
      \ 0\r\n        BC = 3 # Control command (SetVR, Unlock): bypass flag set to\
      \ 1, control command flag set to 1\r\n\r\n    # The type of control command.\r\
      \n    class ControlCommandType(enum.Enum):\r\n        UNLOCK = 0 # COP-1 Unlock\
      \ directive\r\n        SET_VR = 1 # COP-1 SetV(R) directive\r\n        RESERVED\
      \ = 2 # Reserved for future use\r\n\r\n    # The meaning of the sequence flag\
      \ in case of TC segment service.\r\n    class SequenceFlagType(enum.Enum):\r\
      \n        FIRST = 0 # First block\r\n        CONTINUE = 1 # Continuation block\r\
      \n        LAST = 2 # Last block\r\n        NO_SEGMENT = 3 # No segmentation\r\
      \n        \r\n    # Length of the TC Frame header\r\n    TC_PRIMARY_HEADER_LENGTH\
      \ = 5\r\n    # Maximum length of the TC Frame according to CCSDS\r\n    MAX_TC_FRAME_LENGTH\
      \ = 1024\r\n\r\n    def __init__(self, frame, segmented, fecf_present, sec_header_length=0,\
      \ sec_trailer_length=0, req_tag=0, operation_tag=0):\r\n        self.frame =\
      \ frame # The decoded transfer frame.\r\n        self.segmented = segmented\r\
      \n        self.fecf_present = fecf_present # Frame error control field presence\
      \ flag.\r\n        self.security_header_length = sec_header_length\r\n     \
      \   self.security_trailer_length = sec_trailer_length\r\n        self.req_tag\
      \ = req_tag\r\n        self.operation_tag = operation_tag\r\n\r\n        # Check\
      \ transfer frame version number\r\n        two_octets = struct.unpack('>H',\
      \ frame[:2])[0]\r\n        tfvn = (two_octets & 0xC000) >> 14\r\n        if\
      \ tfvn != 0:\r\n            raise ValueError(f\"Transfer Frame Version Number:\
      \ expected 0, actual {tfvn}\")\r\n\r\n        # Primary header fields\r\n  \
      \      self.transfer_frame_version_number = tfvn # Transfer frame version number.\r\
      \n        self.bypass_flag = (two_octets & 0x2000) != 0\r\n        self.control_command_flag\
      \ = (two_octets & 0x1000) != 0\r\n        self.spacecraft_id = two_octets &\
      \ 0x03FF # Spacecraft id.\r\n\r\n        two_octets = struct.unpack('>H', frame[2:4])[0]\
      \ #next 2 octets\r\n        self.virtual_channel_id = (two_octets & 0xFC00)\
      \ >> 10 # Virtual channel id.\r\n        self.frame_length = (two_octets & 0x03FF)\
      \ + 1\r\n        self.control_command_type = None\r\n        self.set_vr_value\
      \ = None\r\n        self.ocf_present = None\r\n\r\n        if self.frame_length\
      \ != len(frame):\r\n            raise ValueError(f\"Wrong Frame Length: expected\
      \ {len(frame)}, actual {self.frame_length}\")\r\n\r\n        self.virtual_channel_frame_count\
      \ = struct.unpack('B', frame[4:5])[0] #last octet # Frame count on the virtual\
      \ channel, this frame belongs to.\r\n\r\n        if self.security_header_length\
      \ > 0:\r\n            self.data_field_start = self.TC_PRIMARY_HEADER_LENGTH\
      \ + (1 if self.segmented else 0) + self.security_header_length # Data field\
      \ start offset from the beginning of the frame.\r\n            self.data_field_length\
      \ = self.frame_length - self.data_field_start - self.security_trailer_length\
      \ - (2 if self.fecf_present else 0) # Length of the data field (i.e. excluding\
      \ FECF, OCF and security fields, if present\r\n        else:\r\n           \
      \ self.data_field_start = self.TC_PRIMARY_HEADER_LENGTH\r\n            self.data_field_length\
      \ = self.frame_length - self.data_field_start - (2 if self.fecf_present else\
      \ 0)\r\n\r\n        if self.get_frame_type() == TcTransferFrame.FrameType.BC:\r\
      \n            data_field_length = len(frame) - self.data_field_start - (2 if\
      \ self.fecf_present else 0) - self.security_trailer_length\r\n            if\
      \ data_field_length == 1:\r\n                self.control_command_type = TcTransferFrame.ControlCommandType.UNLOCK\
      \ if frame[self.data_field_start + self.security_header_length] == 0x00 else\
      \ TcTransferFrame.ControlCommandType.RESERVED\r\n            elif data_field_length\
      \ == 3:\r\n                if frame[self.data_field_start] == 0x82 and frame[self.data_field_start\
      \ + 1] == 0x00:\r\n                    self.control_command_type = TcTransferFrame.ControlCommandType.SET_VR\r\
      \n                    self.set_vr_value = struct.unpack('B', frame[self.data_field_start\
      \ + 2:self.data_field_start + 3])[0]\r\n                else:\r\n          \
      \          self.control_command_type = TcTransferFrame.ControlCommandType.RESERVED\r\
      \n            else:\r\n                self.control_command_type = TcTransferFrame.ControlCommandType.RESERVED\r\
      \n\r\n        if self.segmented and self.get_frame_type() != TcTransferFrame.FrameType.BC:\r\
      \n            seg_header = frame[self.TC_PRIMARY_HEADER_LENGTH]\r\n        \
      \    self.map_id = seg_header & 0x3F\r\n            self.sequence_flag = TcTransferFrame.SequenceFlagType((seg_header\
      \ & 0xC0) >> 6)\r\n\r\n        if self.fecf_present:\r\n            self.valid\
      \ = self.check_validity() # FECF result: valid value only if fecfPresent is\
      \ true. If there is no FECF, then the frame is considered valid.\r\n       \
      \ else:\r\n            self.valid = True\r\n\r\n    # Check fecf\r\n    def\
      \ check_validity(self):\r\n        crc16 = self.get_crc16(self.frame,0,self.frame_length-2)\r\
      \n        crc_from_frame = self.get_fecf()\r\n        return crc16 == crc_from_frame\r\
      \n\r\n    # Return frame type (BC/BD/AD)\r\n    def get_frame_type(self):\r\n\
      \        if self.bypass_flag:\r\n            return TcTransferFrame.FrameType.BC\
      \ if self.control_command_flag else TcTransferFrame.FrameType.BD\r\n       \
      \ else:\r\n            return TcTransferFrame.FrameType.RESERVED if self.control_command_flag\
      \ else TcTransferFrame.FrameType.AD\r\n\r\n    def is_idle_frame(self):\r\n\
      \        return False\r\n\r\n    # Return bypass flag\r\n    def is_bypass_flag(self):\r\
      \n        return self.bypass_flag\r\n\r\n    # Return control command flag\r\
      \n    def is_control_command_flag(self):\r\n        return self.control_command_flag\r\
      \n\r\n    # Return control command type (unlock/set v(r))\r\n    def get_control_command_type(self):\r\
      \n        return self.control_command_type\r\n\r\n    # Return set v(r) value\r\
      \n    def get_set_vr_value(self):\r\n        return self.set_vr_value\r\n\r\n\
      \    # Return map id\r\n    def get_map_id(self):\r\n        return self.map_id\r\
      \n\r\n    # Return sequence flag (first/continue/last/no segment)\r\n    def\
      \ get_sequence_flag(self):\r\n        return self.sequence_flag\r\n\r\n    #\
      \ Return segmented\r\n    def is_segmented(self):\r\n        return self.segmented\r\
      \n\r\n    # Return security\r\n    def is_security_used(self):\r\n        return\
      \ self.security_header_length != 0 or self.security_trailer_length != 0\r\n\r\
      \n    # Return security header length\r\n    def get_security_header_length(self):\r\
      \n        return self.security_header_length\r\n\r\n    # Return security trailer\
      \ length\r\n    def get_security_trailer_length(self):\r\n        return self.security_trailer_length\r\
      \n\r\n    # Return a copy of security header\r\n    def get_security_header_copy(self):\r\
      \n        return copy.deepcopy(self.frame[self.TC_PRIMARY_HEADER_LENGTH + (1\
      \ if self.segmented else 0):self.TC_PRIMARY_HEADER_LENGTH + (1 if self.segmented\
      \ else 0) + self.security_header_length])\r\n\r\n    # Return a copy of security\
      \ trailer\r\n    def get_security_trailer_copy(self):\r\n        return copy.deepcopy(self.frame[-(2\
      \ if self.fecf_present else 0) - self.security_trailer_length:-2 if self.fecf_present\
      \ else None])\r\n\r\n    # Calculate crc16 \r\n    def get_crc16(self, frame,\
      \ offset, length) -> int:\r\n        crc = 0xFFFF\r\n        for i in range(offset,\
      \ offset + length):\r\n            crc ^= frame[i] << 8\r\n            for _\
      \ in range(8):\r\n                if crc & 0x8000:\r\n                    crc\
      \ = (crc << 1) ^ 0x1021\r\n                else:\r\n                    crc\
      \ <<= 1\r\n        return crc & 0xFFFF\r\n\r\n    # Return fecf\r\n    def get_fecf(self):\r\
      \n        return struct.unpack('>H', self.frame[-2:])[0]\r\n\r\n    # Return\
      \ transfer frame length\r\n    def get_length(self):\r\n        return len(self.frame)\r\
      \n\r\n    # Return fecf present\r\n    def is_fecf_present(self):\r\n      \
      \  return self.fecf_present\r\n\r\n    # Return transfer frame version number\r\
      \n    def get_transfer_frame_version_number(self):\r\n        return self.transfer_frame_version_number\r\
      \n\r\n    # Return spacecraft id\r\n    def get_spacecraft_id(self):\r\n   \
      \     return self.spacecraft_id\r\n\r\n    # Return virtual channel id\r\n \
      \   def get_virtual_channel_id(self):\r\n        return self.virtual_channel_id\r\
      \n\r\n    # Return virtual channel frame count\r\n    def get_virtual_channel_frame_count(self):\r\
      \n        return self.virtual_channel_frame_count\r\n\r\n    # Return start\
      \ index of data field \r\n    def get_data_field_start(self):\r\n        return\
      \ self.data_field_start\r\n\r\n    # Return valid\r\n    def is_valid(self):\r\
      \n        return self.valid\r\n\r\n    # Return idle frame\r\n    def is_idle_frame(self):\r\
      \n        return False\r\n\r\n    # Return a copy of the frame data field.\r\
      \n    def get_data_field_copy(self):\r\n        return copy.deepcopy(self.frame[self.data_field_start:self.data_field_start\
      \ + self.get_data_field_length()])\r\n\r\n    # Return the length of the data\
      \ field.\r\n    def get_data_field_length(self):\r\n        return self.data_field_length\r\
      \n    \r\n    # Return request tag\r\n    def get_req_tag(self):\r\n       \
      \ return self.req_tag\r\n    \r\n    # Return operation tag\r\n    def get_operation_tag(self):\r\
      \n        return self.operation_tag\r\n\r\n    def __str__(self):\r\n      \
      \  return (\r\n            f\"TcTransferFrame{{bypassFlag={self.bypass_flag},\
      \ controlCommandFlag={self.control_command_flag}, \"\r\n            f\"frameLength={self.frame_length},\
      \ segmented={self.segmented}, mapId={self.map_id}, \"\r\n            f\"sequenceFlag={self.sequence_flag},\
      \ controlCommandType={self.control_command_type}, \"\r\n            f\"setVrValue={self.set_vr_value},\
      \ securityHeaderLength={self.security_header_length}, \"\r\n            f\"\
      securityTrailerLength={self.security_trailer_length}, fecfPresent={self.fecf_present},\
      \ \"\r\n            f\"ocfPresent={self.ocf_present}, transferFrameVersionNumber={self.transfer_frame_version_number},\
      \ \"\r\n            f\"spacecraftId={self.spacecraft_id}, virtualChannelId={self.virtual_channel_id},\
      \ \"\r\n            f\"virtualChannelFrameCount={self.virtual_channel_frame_count},\
      \ valid={self.valid}}}\"\r\n        )\r\n"
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [304, 412.0]
    rotation: 0
    state: enabled
- name: TcTransferFrameBuilder
  id: epy_module
  parameters:
    alias: ''
    comment: ''
    source_code: "import struct\r\nimport numpy as np\r\nfrom overall_TcTransferFrame\
      \ import TcTransferFrame\r\n\r\n# Create a TcTransferFrame object from a valid\
      \ parameters indicating the fields of TC transfer frame header and data\r\n\
      class TcTransferFrameBuilder:\r\n    def __init__(self, fecf_present):\r\n \
      \       self.fecf_present = fecf_present\r\n        self.bypass_flag = False\r\
      \n        self.control_command_flag = False\r\n        self.spacecraft_id =\
      \ 0\r\n        self.virtual_channel_id = 0\r\n        self.frame_sequence_number\
      \ = 0\r\n        self.free_user_data_length = 0\r\n        self.map_id = 0\r\
      \n        self.segmented = False\r\n        self.sequence_flag = 0\r\n     \
      \   self.security_header = bytearray()\r\n        self.security_trailer = bytearray()\r\
      \n        self.payload_units = []\r\n        self.operation_tag = 0\r\n    \
      \    self.req_tag = 0\r\n\r\n        self.MAX_TC_FRAME_LENGTH = 1024\r\n   \
      \     self.TC_PRIMARY_HEADER_LENGTH = 5\r\n\r\n        # Calculate initial free\
      \ user data length\r\n        self.free_user_data_length = self.compute_max_user_data_length()\r\
      \n\r\n    # Calculate the max possible user data length\r\n    def compute_max_user_data_length(self):\r\
      \n        return self.MAX_TC_FRAME_LENGTH - self.TC_PRIMARY_HEADER_LENGTH -\
      \ (2 if self.fecf_present else 0)\r\n\r\n    # Set bypass flag\r\n    def set_bypass_flag(self,\
      \ bypass_flag):\r\n        self.bypass_flag = bypass_flag\r\n        return\
      \ self\r\n\r\n    # Set control command flag\r\n    def set_control_command_flag(self,\
      \ control_command_flag):\r\n        self.control_command_flag = control_command_flag\r\
      \n        return self\r\n\r\n    # Set spacecraft id\r\n    def set_spacecraft_id(self,\
      \ spacecraft_id):\r\n        if not (0 <= spacecraft_id <= 1023):\r\n      \
      \      raise ValueError(\"Spacecraft ID must be 0 <= SC ID <= 1023, actual {}\"\
      .format(spacecraft_id))\r\n        self.spacecraft_id = spacecraft_id\r\n  \
      \      return self\r\n\r\n    # Set virtual channel id\r\n    def set_virtual_channel_id(self,\
      \ virtual_channel_id):\r\n        if not (0 <= virtual_channel_id <= 63):\r\n\
      \            raise ValueError(\"Virtual Channel ID must be 0 <= VC ID <= 63,\
      \ actual {}\".format(virtual_channel_id))\r\n        self.virtual_channel_id\
      \ = virtual_channel_id\r\n        return self\r\n\r\n    # Set frame sequence\
      \ number\r\n    def set_frame_sequence_number(self, frame_sequence_number):\r\
      \n        if not (0 <= frame_sequence_number <= 255):\r\n            raise ValueError(\"\
      Frame Sequence Number must be 0 <= seq. num. <= 255, actual {}\".format(frame_sequence_number))\r\
      \n        self.frame_sequence_number = frame_sequence_number\r\n        return\
      \ self\r\n\r\n    # Set segmented flag, sequence flag, map id\r\n    def set_segment(self,\
      \ sequence_flag, map_id):\r\n        if not (0 <= map_id <= 63):\r\n       \
      \     raise ValueError(\"Map ID must be 0 <= Map ID <= 64, actual {}\".format(map_id))\r\
      \n        if self.is_full():\r\n            raise ValueError(\"TC Frame already\
      \ full\")\r\n        if not self.segmented:\r\n            self.segmented =\
      \ True\r\n            self.free_user_data_length -= 1\r\n        self.sequence_flag\
      \ = sequence_flag\r\n        self.map_id = map_id\r\n        return self\r\n\
      \r\n    # Set unlock control command (for BC unlock frame)\r\n    def set_unlock_control_command(self):\r\
      \n        # CCSDS 232.0-B-3, 4.1.3.3.2\r\n        self.add_data(bytes([0x00]))\r\
      \n        return self\r\n\r\n    # Set set v(r) control command (for BC set\
      \ v(r) frame)\r\n    def set_set_vr_control_command(self, frame_sequence_number):\r\
      \n        if not (0 <= frame_sequence_number <= 255):\r\n            raise ValueError(\"\
      Set V(R) Sequence Number must be 0 <= V(R) <= 255, actual {}\".format(frame_sequence_number))\r\
      \n        # CCSDS 232.0-B-3, 4.1.3.3.3\r\n        self.add_data(bytes([0x82,\
      \ 0x00, frame_sequence_number]))\r\n        return self\r\n\r\n    # Set security\
      \ header and trailer\r\n    def set_security(self, header, trailer):\r\n   \
      \     if header is None and trailer is None:\r\n            return self\r\n\
      \        if self.is_full():\r\n            raise ValueError(\"TC Frame already\
      \ full\")\r\n        security_data_size = (len(header) if header else 0) + (len(trailer)\
      \ if trailer else 0)\r\n        if self.free_user_data_length < security_data_size:\r\
      \n            raise ValueError(\"TC Frame cannot accommodate additional {} bytes,\
      \ remaining space is {} bytes\".format(security_data_size, self.free_user_data_length))\r\
      \n        self.security_header = header if header else bytearray()\r\n     \
      \   self.security_trailer = trailer if trailer else bytearray()\r\n        self.free_user_data_length\
      \ -= security_data_size\r\n        return self\r\n    \r\n    # Set request\
      \ tag\r\n    def set_req_tag(self, req_tag):\r\n        self.req_tag = req_tag\r\
      \n        return self\r\n    \r\n    # Set operation tag\r\n    def set_operation_tag(self,\
      \ operation_tag):\r\n        self.operation_tag = operation_tag\r\n        return\
      \ self\r\n\r\n    # Add user data\r\n    def add_data(self, data):\r\n     \
      \   # Compute if you can add the requested amount\r\n        data_to_be_written\
      \ = min(self.free_user_data_length, len(data))\r\n        not_written_data =\
      \ len(data) - data_to_be_written\r\n        if data_to_be_written > 0:\r\n \
      \           self.payload_units.append(data[:data_to_be_written])\r\n       \
      \     self.free_user_data_length -= data_to_be_written\r\n        return not_written_data\r\
      \n\r\n    # Get user data length\r\n    def get_free_user_data_length(self):\r\
      \n        return self.free_user_data_length\r\n\r\n    # Get whether user data\
      \ field is full\r\n    def is_full(self):\r\n        return self.free_user_data_length\
      \ == 0\r\n    \r\n    # Calculate crc16\r\n    def get_crc16(self, data: bytes,\
      \ start: int, length: int) -> int:\r\n        crc = 0xFFFF\r\n        for i\
      \ in range(start, start + length):\r\n            crc ^= data[i] << 8\r\n  \
      \          for _ in range(8):\r\n                if crc & 0x8000:\r\n      \
      \              crc = (crc << 1) ^ 0x1021\r\n                else:\r\n      \
      \              crc <<= 1\r\n        return crc & 0xFFFF\r\n\r\n    # Build and\
      \ return the tc transfer frame\r\n    def build(self):\r\n        payload_data_length\
      \ = sum(len(pu) for pu in self.payload_units)\r\n        frame_length = self.TC_PRIMARY_HEADER_LENGTH\
      \ + payload_data_length + (2 if self.fecf_present else 0) + (1 if self.segmented\
      \ else 0)\r\n        if self.security_header:\r\n            frame_length +=\
      \ len(self.security_header)\r\n        if self.security_trailer:\r\n       \
      \     frame_length += len(self.security_trailer)\r\n\r\n        encoded_frame\
      \ = bytearray()\r\n        encoded_frame.extend(struct.pack('>H', (self.bypass_flag\
      \ << 13) | (self.control_command_flag << 12) | self.spacecraft_id))\r\n    \
      \    encoded_frame.extend(struct.pack('>H', (self.virtual_channel_id << 10)\
      \ | (frame_length - 1)))\r\n        encoded_frame.append(self.frame_sequence_number)\r\
      \n\r\n        if self.segmented:\r\n            to_write = (self.sequence_flag.value\
      \ << 6) | self.map_id\r\n            encoded_frame.append(to_write)\r\n\r\n\
      \        # If security header, write it\r\n        encoded_frame.extend(self.security_header)\r\
      \n\r\n        # Write the user data\r\n        for pu in self.payload_units:\r\
      \n            encoded_frame.extend(pu)\r\n\r\n        # If security trailer,\
      \ write it\r\n        encoded_frame.extend(self.security_trailer)\r\n\r\n  \
      \      # Compute and write the FECF (if present, 2 bytes)\r\n        if self.fecf_present:\r\
      \n            crc = np.uint16(0)\r\n            crc = self.get_crc16(encoded_frame,\
      \ 0, len(encoded_frame) - 2)\r\n            encoded_frame.extend(struct.pack('>H',\
      \ crc))\r\n\r\n        # Return the frame\r\n        return TcTransferFrame(bytes(encoded_frame),\
      \ lambda vc: self.segmented, self.fecf_present, len(self.security_header), len(self.security_trailer),\
      \ self.req_tag, self.operation_tag)\r\n"
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [304, 540.0]
    rotation: 0
    state: enabled
- name: TransferFrameCollector
  id: epy_module
  parameters:
    alias: ''
    comment: ''
    source_code: "from overall_TcTransferFrame import TcTransferFrame\r\n\r\n# Store\
      \ AD and BD frames, where the TcSenderVirtualChannel will put in AD/BD frames\
      \ created and Cop Execute will retrieve the frames\r\nclass TransferFrameCollector:\r\
      \n    def __init__(self):\r\n        self.frame_list = []\r\n\r\n    # Return\
      \ and remove first frame from frame_list (if exists), clear list if clear_list\
      \ = True\r\n    def retrieve_first(self, clear_list=True):\r\n        first_frame\
      \ = self.frame_list.pop(0) if self.frame_list else None\r\n        if clear_list:\r\
      \n            self.frame_list.clear()\r\n        return first_frame\r\n\r\n\
      \    # Return a copy of the current frame_list and clears frame_list\r\n   \
      \ def retrieve(self):\r\n        copied_list = self.frame_list.copy()\r\n  \
      \      self.frame_list.clear()\r\n        return copied_list\r\n\r\n    # Add\
      \ generated_frame to frame_list if it is a AD/BD frame\r\n    def transfer_frame_generated(self,\
      \ virtual_channel, generated_frame, buffered_bytes):\r\n        if generated_frame.get_frame_type()\
      \ == TcTransferFrame.FrameType.AD or generated_frame.get_frame_type() == TcTransferFrame.FrameType.BD:\r\
      \n            self.frame_list.append(generated_frame)\r\n"
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [304, 348.0]
    rotation: 0
    state: enabled
- name: VirtualChannelAccessMode
  id: epy_module
  parameters:
    alias: ''
    comment: ''
    source_code: "from enum import Enum\r\n\r\n# Enumerate virtual channel access\
      \ modes\r\nclass VirtualChannelAccessMode(Enum):\r\n    PACKET=0\r\n    BITSTREAM=1\r\
      \n    DATA=2\r\n    ENCAPSULATION=3"
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [64, 668.0]
    rotation: 0
    state: true
- name: analog_noise_source_x_0
  id: analog_noise_source_x
  parameters:
    affinity: ''
    alias: ''
    amp: 1e-3
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    noise_type: analog.GR_GAUSSIAN
    seed: '0'
    type: complex
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [4096, 1876.0]
    rotation: 0
    state: enabled
- name: analog_noise_source_x_0_0
  id: analog_noise_source_x
  parameters:
    affinity: ''
    alias: ''
    amp: 1e-3
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    noise_type: analog.GR_GAUSSIAN
    seed: '0'
    type: complex
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1824, 1836.0]
    rotation: 0
    state: enabled
- name: blocks_add_xx_0_0
  id: blocks_add_xx
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    num_inputs: '2'
    type: complex
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [4400, 1844.0]
    rotation: 0
    state: enabled
- name: blocks_add_xx_0_0_0
  id: blocks_add_xx
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    num_inputs: '2'
    type: complex
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [2128, 1796.0]
    rotation: 0
    state: enabled
- name: blocks_char_to_float_0
  id: blocks_char_to_float
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    scale: '1'
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1680, 2196.0]
    rotation: 0
    state: enabled
- name: blocks_char_to_float_0_0
  id: blocks_char_to_float
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    scale: '1'
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [2360, 292.0]
    rotation: 0
    state: disabled
- name: blocks_delay_0
  id: blocks_delay
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    delay: delay
    maxoutbuf: '0'
    minoutbuf: '0'
    num_ports: '1'
    showports: 'False'
    type: float
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [2608, 292.0]
    rotation: 0
    state: disabled
- name: blocks_file_sink_0
  id: blocks_file_sink
  parameters:
    affinity: ''
    alias: ''
    append: 'False'
    comment: ''
    file: telemetryout_test.txt
    type: byte
    unbuffered: 'True'
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [4528, 1012.0]
    rotation: 0
    state: disabled
- name: blocks_file_sink_2
  id: blocks_file_sink
  parameters:
    affinity: ''
    alias: ''
    append: 'False'
    comment: ''
    file: received_signal.txt
    type: complex
    unbuffered: 'False'
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [4696, 1804.0]
    rotation: 0
    state: disabled
- name: blocks_file_source_0
  id: blocks_file_source
  parameters:
    affinity: ''
    alias: ''
    begin_tag: pmt.PMT_NIL
    comment: ''
    file: received_signal.txt
    length: '0'
    maxoutbuf: '0'
    minoutbuf: '0'
    offset: '0'
    repeat: 'False'
    type: complex
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [2744, 2452.0]
    rotation: 0
    state: disabled
- name: blocks_file_source_1
  id: blocks_file_source
  parameters:
    affinity: ''
    alias: ''
    begin_tag: pmt.PMT_NIL
    comment: ''
    file: telemetryout_test.txt
    length: '0'
    maxoutbuf: '0'
    minoutbuf: '0'
    offset: '0'
    repeat: 'True'
    type: byte
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [2856, 1532.0]
    rotation: 0
    state: enabled
- name: blocks_file_source_1_0
  id: blocks_file_source
  parameters:
    affinity: ''
    alias: ''
    begin_tag: pmt.PMT_NIL
    comment: ''
    file: duplicated.txt
    length: '0'
    maxoutbuf: '0'
    minoutbuf: '0'
    offset: '0'
    repeat: 'False'
    type: byte
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [2856, 1316.0]
    rotation: 0
    state: disabled
- name: blocks_file_source_3
  id: blocks_file_source
  parameters:
    affinity: ''
    alias: ''
    begin_tag: pmt.intern("length_tag")
    comment: ''
    file: COP_Requests\fop_test_clcw.txt
    length: '223'
    maxoutbuf: '0'
    minoutbuf: '0'
    offset: '0'
    repeat: 'False'
    type: byte
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [2672, 900.0]
    rotation: 0
    state: disabled
- name: blocks_multiply_const_vxx_0
  id: blocks_multiply_const_vxx
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    const: 400e-3
    maxoutbuf: '0'
    minoutbuf: '0'
    type: complex
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1280, 1300.0]
    rotation: 0
    state: enabled
- name: blocks_multiply_const_vxx_0_0_0
  id: blocks_multiply_const_vxx
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    const: push_button
    maxoutbuf: '0'
    minoutbuf: '0'
    type: complex
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [3560, 1364.0]
    rotation: 0
    state: enabled
- name: blocks_pack_k_bits_bb_0_0
  id: blocks_pack_k_bits_bb
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    k: '8'
    maxoutbuf: '0'
    minoutbuf: '0'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [4136, 1124.0]
    rotation: 0
    state: disabled
- name: blocks_phase_shift_0
  id: blocks_phase_shift
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    is_radians: 'True'
    maxoutbuf: '0'
    minoutbuf: '0'
    shift: '0.9'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [4120, 1768.0]
    rotation: 0
    state: enabled
- name: blocks_phase_shift_0_0
  id: blocks_phase_shift
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    is_radians: 'True'
    maxoutbuf: '0'
    minoutbuf: '0'
    shift: '0.9'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1848, 1720.0]
    rotation: 0
    state: enabled
- name: blocks_repack_bits_bb_0_0
  id: blocks_repack_bits_bb
  parameters:
    affinity: ''
    alias: ''
    align_output: 'False'
    comment: ''
    endianness: gr.GR_MSB_FIRST
    k: '8'
    l: '1'
    len_tag_key: '"packet_len"'
    maxoutbuf: '0'
    minoutbuf: '0'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [3752, 936.0]
    rotation: 0
    state: disabled
- name: blocks_throttle2_0
  id: blocks_throttle2
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    ignoretag: 'True'
    limit: auto
    maximum: '0.1'
    maxoutbuf: '0'
    minoutbuf: '0'
    samples_per_second: samp_rate
    type: complex
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [3816, 1760.0]
    rotation: 0
    state: enabled
- name: blocks_throttle2_0_0
  id: blocks_throttle2
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    ignoretag: 'True'
    limit: auto
    maximum: '0.1'
    maxoutbuf: '0'
    minoutbuf: '0'
    samples_per_second: samp_rate
    type: complex
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1544, 1712.0]
    rotation: 0
    state: enabled
- name: blocks_throttle2_2
  id: blocks_throttle2
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    ignoretag: 'True'
    limit: auto
    maximum: '0.1'
    maxoutbuf: '0'
    minoutbuf: '0'
    samples_per_second: samp_rate
    type: byte
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [3056, 952.0]
    rotation: 0
    state: disabled
- name: blocks_unpack_k_bits_bb_0_0_0_1_0
  id: blocks_unpack_k_bits_bb
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    k: '8'
    maxoutbuf: '0'
    minoutbuf: '0'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [2104, 292.0]
    rotation: 0
    state: disabled
- name: blocks_vector_source_x_0
  id: blocks_vector_source_x
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    repeat: 'True'
    tags: '[packet_len]'
    type: byte
    vector: (0,10,20,30,40,50,60,70,80,90,0,10,20,30,40,50,60,70,80,90)
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [496, 1460.0]
    rotation: 0
    state: disabled
- name: blocks_vector_source_x_1
  id: blocks_vector_source_x
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    repeat: 'False'
    tags: '[packet_len]'
    type: byte
    vector: (0, 0, 0, 0, 0)
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1416, 108.0]
    rotation: 0
    state: disabled
- name: digital_constellation_decoder_cb_0
  id: digital_constellation_decoder_cb
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    constellation: bpsk
    maxoutbuf: '0'
    minoutbuf: '0'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1360, 2196.0]
    rotation: 0
    state: enabled
- name: digital_constellation_modulator_0
  id: digital_constellation_modulator
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    constellation: bpsk
    differential: 'False'
    excess_bw: '0.35'
    log: 'False'
    maxoutbuf: '0'
    minoutbuf: '0'
    samples_per_symbol: sps
    truncate: 'False'
    verbose: 'False'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [904, 1264.0]
    rotation: 0
    state: enabled
- name: digital_constellation_modulator_0_0_0
  id: digital_constellation_modulator
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    constellation: bpsk
    differential: 'False'
    excess_bw: '0.35'
    log: 'False'
    maxoutbuf: '0'
    minoutbuf: '0'
    samples_per_symbol: sps
    truncate: 'False'
    verbose: 'False'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [3232, 1336.0]
    rotation: 0
    state: enabled
- name: digital_constellation_soft_decoder_cf_0_0
  id: digital_constellation_soft_decoder_cf
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    constellation: bpsk
    maxoutbuf: '0'
    minoutbuf: '0'
    npwr: '-1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [3824, 2200.0]
    rotation: 0
    state: enabled
- name: digital_costas_loop_cc_0
  id: digital_costas_loop_cc
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    order: '2'
    use_snr: 'False'
    w: 50e-3
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [992, 2084.0]
    rotation: 0
    state: enabled
- name: digital_costas_loop_cc_0_0_0
  id: digital_costas_loop_cc
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    order: '2'
    use_snr: 'False'
    w: 50e-3
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [3520, 2116.0]
    rotation: 0
    state: enabled
- name: digital_pfb_clock_sync_xxx_0
  id: digital_pfb_clock_sync_xxx
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    filter_size: '32'
    init_phase: '16'
    loop_bw: 63e-3
    max_dev: '1.5'
    maxoutbuf: '0'
    minoutbuf: '0'
    osps: '1'
    sps: sps
    taps: rrc_taps
    type: ccf
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [568, 2080.0]
    rotation: 0
    state: enabled
- name: digital_pfb_clock_sync_xxx_0_0_0
  id: digital_pfb_clock_sync_xxx
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    filter_size: '32'
    init_phase: '16'
    loop_bw: 63e-3
    max_dev: '1.5'
    maxoutbuf: '0'
    minoutbuf: '0'
    osps: '1'
    sps: sps
    taps: rrc_taps
    type: ccf
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [3168, 2088.0]
    rotation: 0
    state: enabled
- name: epy_block_0
  id: epy_block
  parameters:
    _source_code: "\"\"\"\nAdd a tag to the first data sample of the tm transfer frame,\
      \ with the packet length value attached \nfor the next block 'Tagged Stream\
      \ to PDU' to recognise the boundaries of the tm transfer frame and pack into\
      \ a PDU\n\"\"\"\n\nimport numpy as np\nfrom gnuradio import gr\nimport pmt\n\
      \ \nclass blk(gr.basic_block):\n\n    def __init__(self):\n        gr.basic_block.__init__(\n\
      \            self,\n            name='Custom Tag Stream',\n            in_sig=[np.int8],\n\
      \            out_sig=[np.int8]\n        )\n        \n    # Forecast a larger\
      \ no of output than actual so that the entire data packet will be read together.\
      \ \n    # 1) During runtime, the scheduler asks forecast what input buffer size\
      \ is needed to produce the largest amount of output that the output buffer can\
      \ deal with (32768) \n    # 2) Scheduler checks if the input buffer has enough\
      \ samples, if yes then that amount of output buffer is provided to general_work\
      \ \n    # if no then it halves the output buffer size (16384) and repeat step\
      \ 1 & 2 until it hits the minimum output buffer size (1)\n    # e.g. if packet\
      \ is 223 bytes, output buffer size provided is 256 (as input buffer required\
      \ (256/2 =128) is greater than actual input buffer (223))\n    def forecast(self,\
      \ noutput_items, ninputs):\n        ninput_items_required = [0] * ninputs\n\
      \        if (noutput_items-2 -1 <0):\n            ninput_items_required[0] =\
      \ int(noutput_items)\n        else:\n            ninput_items_required[0] =\
      \ int(noutput_items/2)\n        return ninput_items_required    \n \n    # Add\
      \ a tag to the first data sample of packet with key = name of tag and value\
      \ = length of packet\n    def general_work(self, input_items, output_items):\n\
      \        in_length = len(input_items[0])\n        key = pmt.intern(\"packet_len\"\
      )\n        value = pmt.from_long(in_length)\n        self.add_item_tag(0, #\
      \ Write to output port 0\n                 self.nitems_written(0), # Index of\
      \ the tag in absolute terms\n                 key, # Key of the tag\n      \
      \           value # Value of the tag\n        )\n        print(\"length:\",in_length)\n\
      \        \n        for i in range(0,len(input_items[0]),1):\n            output_items[0][i]\
      \ = input_items[0][i]\n        self.consume(0,len(input_items[0]))\n       \
      \ return len(input_items[0])"
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
  states:
    _io_cache: ('Custom Tag Stream', 'blk', [], [('0', 'byte', 1)], [('0', 'byte',
      1)], '', [])
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [3032, 1064.0]
    rotation: 0
    state: disabled
- name: epy_block_0_0
  id: epy_block
  parameters:
    _source_code: "\"\"\"\nBit randomiser using 255-bit randomisation sequence generated\
      \ using polynomial h(x) = x8 + x6 + x4 + x3 + x2 + x + 1\n\"\"\"\n\nimport numpy\
      \ as np\nfrom gnuradio import gr\nimport pmt\n\nclass blk(gr.basic_block): \
      \ # other base classes are basic_block, decim_block, interp_block\n    # Initialise\
      \ shift registers to \"all ones\" state\n    x1 = x2 = x3 = x4 = x5 = x6 = x7\
      \ = x8 = 1  \n    \n    def __init__(self):  \n        \"\"\"arguments to this\
      \ function show up as parameters in GRC\"\"\"\n        gr.basic_block.__init__(\n\
      \            self,\n            name='Custom PDU Randomiser',   # will show\
      \ up in GRC\n            in_sig=None,\n            out_sig=None\n        )\n\
      \        # Register input message passing port \n        self.message_port_register_in(pmt.intern('msg_in'))\n\
      \        # Register output message passing port\n        self.message_port_register_out(pmt.intern('msg_out'))\n\
      \        # Register message handler for input port 'msg_in', ie specify function\
      \ to call when a message is received on input port \n        self.set_msg_handler(pmt.intern('msg_in'),\
      \ self.handle_msg)\n        \n                \n    def handle_msg(self, msg):\n\
      \        # Convert input message ie pdu to array of bytes\n        input_items\
      \ = np.array(pmt.to_python(pmt.cdr(msg)))\n        output_items = [None]*len(input_items)\n\
      \        # Iterate over each input byte, calculate the randomised output \n\
      \        for i in range(len(input_items)):  \n            output_items[i] =\
      \ self.btg(input_items[i])\n        # Output randomised data to port 'msg_out'\
      \ as a PDU(protocol data unit), which is defined as a PMT pair using pmt.cons(KEY,VALUE)\n\
      \        # where KEY= empty and VALUE= pmt vector of bytes \n        self.message_port_pub(pmt.intern('msg_out'),\
      \ pmt.cons(pmt.PMT_NIL, pmt.init_u8vector(len(output_items), output_items)))\n\
      \        # Reset shift registers\n        self.btg_reset()\n    \n    \"\"\"\
      \n    Bit transition generator using a shift register with feedback.\n    Args:\n\
      \        in_data (int): 8-bit input data to be transformed.\n    Returns:\n\
      \        int: Transformed 8-bit output data.\n    \"\"\"  \n    def btg(self,\
      \ in_data): \n        out_byte = \"\"  # Initialize the output byte as an empty\
      \ string\n        message = format(in_data & 0xFF, '08b')  # Convert input data\
      \ to an 8-bit binary string \n        for i in range(8):  # Iterate over each\
      \ bit in the input data\n            # XOR the first register bit with the current\
      \ message bit and add to output byte\n            out_byte += str(self.x1 ^\
      \ int(message[i]))\n            # Calculate the new feedback value using XOR\
      \ operations\n            xor1 = self.x1 ^ self.x2\n            xor2 = xor1\
      \ ^ self.x3\n            xor3 = xor2 ^ self.x4\n            xor4 = xor3 ^ self.x5\n\
      \            xor5 = xor4 ^ self.x7\n            # Shift the register values\n\
      \            self.x1 = self.x2\n            self.x2 = self.x3\n            self.x3\
      \ = self.x4\n            self.x4 = self.x5\n            self.x5 = self.x6\n\
      \            self.x6 = self.x7\n            self.x7 = self.x8\n            self.x8\
      \ = xor5  # Update the last register value with the final XOR result\n     \
      \   out_data = int(out_byte, 2)  # Convert the output byte string back to an\
      \ integer\n        return out_data  # Return the transformed output data\n\n\
      \    def btg_reset(self):\n        self.x1 = self.x2 = self.x3 = self.x4 = self.x5\
      \ = self.x6 = self.x7 = self.x8 = 1\n\n"
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
  states:
    _io_cache: ('Custom PDU Randomiser', 'blk', [], [('msg_in', 'message', 1)], [('msg_out',
      'message', 1)], 'arguments to this function show up as parameters in GRC', [])
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [808, 960.0]
    rotation: 0
    state: enabled
- name: epy_block_1_0
  id: epy_block
  parameters:
    _source_code: "\"\"\"\nAdd Frame Sync (1ACFFC1D, from CCSDS Telemetry Channel\
      \ Coding 5-2) to the RS encoded TM transfer frame \n\"\"\"\n\nimport numpy as\
      \ np\nfrom gnuradio import gr\nimport pmt\n\nclass blk(gr.sync_block):  # other\
      \ base classes are basic_block, decim_block, interp_block\n    def __init__(self):\
      \  # only default arguments here\n        \"\"\"arguments to this function show\
      \ up as parameters in GRC\"\"\"\n        gr.sync_block.__init__(\n         \
      \   self,\n            name='Custom Add Frame Sync',   # will show up in GRC\n\
      \            in_sig=None,\n            out_sig=None\n        )\n        self.message_port_register_in(pmt.intern('msg_in'))\n\
      \        self.message_port_register_out(pmt.intern('msg_out'))\n        self.set_msg_handler(pmt.intern('msg_in'),\
      \ self.handle_msg)\n        \n    def handle_msg(self, msg):\n        data =\
      \ np.concatenate((np.array([int(\"00011010\",2),int(\"11001111\",2),int(\"11111100\"\
      ,2),int(\"00011101\",2)]), np.array(pmt.to_python(pmt.cdr(msg)))))\n       \
      \ self.message_port_pub(pmt.intern('msg_out'), pmt.cons(pmt.PMT_NIL, pmt.init_u8vector(len(data),\
      \ data)))\n\n     \n\n    "
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
  states:
    _io_cache: ('Custom Add Frame Sync', 'blk', [], [('msg_in', 'message', 1)], [('msg_out',
      'message', 1)], 'arguments to this function show up as parameters in GRC', [])
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [3400, 1060.0]
    rotation: 0
    state: disabled
- name: epy_block_2
  id: epy_block
  parameters:
    _source_code: "\"\"\"\n(64,56) modified BCH Encoding, polynomial h(x) = x7 + x6\
      \ + x2 + 1\n\"\"\"\n\nimport numpy as np\nfrom gnuradio import gr\nimport pmt\n\
      \nclass blk(gr.basic_block):  # other base classes are basic_block, decim_block,\
      \ interp_block\n    # Total no of bytes in BCH Codeblock  \n    n = 8\n    #\
      \ No of data bytes in BCH Codeblock\n    k = 7\n    a = -1\n    \n    def __init__(self):\
      \  # only default arguments here\n        \"\"\"arguments to this function show\
      \ up as parameters in GRC\"\"\"\n        gr.basic_block.__init__(\n        \
      \    self,\n            name='Custom PDU BCH',   # will show up in GRC\n   \
      \         in_sig=None,\n            out_sig=None\n        )\n        # Register\
      \ input message passing port \n        self.message_port_register_in(pmt.intern('msg_in'))\n\
      \        # Register output message passing port\n        self.message_port_register_out(pmt.intern('msg_out'))\n\
      \        # Register message handler for input port 'msg_in', ie specify function\
      \ to call when a message is received on input port \n        self.set_msg_handler(pmt.intern('msg_in'),\
      \ self.handle_msg)  \n        \n    # Get the number of bch blks, calculate\
      \ the bch parity and concatenate to each blk\n    def handle_msg(self, msg):\
      \  \n        input_items = np.array(pmt.to_python(pmt.cdr(msg)))\n        blks\
      \ = int((len(input_items)/self.k)) # No of BCH blocks in transfer frame\n  \
      \      \n        in56 = [None]*self.k # 7 element array for storing data bytes\
      \ of BCH block\n        out64 = [None]*self.n # 8 element array for storing\
      \ BCH block\n        output_items = [None]*(blks*self.n) # output array\n\n\
      \        if (blks < 1):\n            if (self.a == -1):\n                print(\"\
      Error: not enough input data\")\n                self.a = 0\n            return\
      \ 0\n        # Calculate and fill parity bits for each BCH codeblock\n     \
      \   for i in range(blks):\n            for j in range(self.k):\n           \
      \     in56[j] = input_items[j+i*self.k]\n            out64 = self.bch(in56)\n\
      \            for j in range(self.n):\n                output_items[j+i*self.n]\
      \ = out64[j]\n        self.message_port_pub(pmt.intern('msg_out'), pmt.cons(pmt.PMT_NIL,\
      \ pmt.init_u8vector(len(output_items), output_items)))\n         \n    # BCH\
      \ error encoding\n    def bch(self, in56):\n        # Initialize the output\
      \ array with None values\n        out64 = [None] * self.n\n        message =\
      \ \"\"  # Initialize an empty string to store the binary representation of the\
      \ input bytes\n\n        # Loop over the first 8 bytes of the input\n      \
      \  for i in range(self.n):\n            if i < self.k:\n                # Process\
      \ the first 7 bytes\n                byte = in56[i]\n                out64[i]\
      \ = byte  # Store the byte in the output array\n                message += format(byte\
      \ & 0xFF, '08b')  # Convert byte to an 8-bit binary string and append to message\n\
      \            if i == self.k:\n                # Process the 8th byte (parity\
      \ calculation)\n                out_parity = \"\"  # Initialize an empty string\
      \ for the parity bits\n                x0 = x1 = x2 = x3 = x4 = x5 = x6 = 0\
      \  # Initialize shift register bits to 0\n                parity = x6 ^ 1  #\
      \ Initial parity value, inverted x6\n\n                # Loop over 64 bits to\
      \ calculate parity\n                for j in range(64):\n                  \
      \  if j < 56:\n                        # Process the first 56 bits of the message\n\
      \                        bitin = int(message[j])  # Get the j-th bit from the\
      \ message\n                        bitin2 = x6 ^ bitin  # XOR the bit with x6\n\
      \                    if 56 <= j < 63:\n                        # Process bits\
      \ 56 to 62 (parity bits)\n                        out_parity += str(parity)\
      \  # Append the current parity bit to out_parity\n                        bitin2\
      \ = 0  # No input bit for these positions\n                    if j == 63:\n\
      \                        # Process the 63rd bit (final parity bit)\n       \
      \                 out_parity += \"0\"  # Append a 0 to out_parity\n        \
      \                bitin2 = 0  # No input bit for this position\n\n          \
      \          # Update the shift register bits with XOR logic\n               \
      \     x6 = x5 ^ bitin2\n                    x5 = x4\n                    x4\
      \ = x3\n                    x3 = x2\n                    x2 = x1 ^ bitin2\n\
      \                    x1 = x0\n                    x0 = bitin2\n\n          \
      \          # Update parity with the inverted x6\n                    parity\
      \ = x6 ^ 1\n\n                # Convert the parity bits from binary string to\
      \ integer and store in the output array\n                out64[i] = int(out_parity,\
      \ 2)\n\n        # Return the final 64-byte output array\n        return out64\n"
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
  states:
    _io_cache: ('Custom PDU BCH', 'blk', [], [('msg_in', 'message', 1)], [('msg_out',
      'message', 1)], 'arguments to this function show up as parameters in GRC', [])
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1544, 964.0]
    rotation: 0
    state: enabled
- name: epy_block_2_1
  id: epy_block
  parameters:
    _source_code: "\"\"\"\nPerform symbol inversion for the output path of the 2nd\
      \ polynomial (1011011 or 133 octal) of the convolutional encoder\ni.e. invert\
      \ the 2nd,4th,6th,... bits (bit 1,3,5,...)\n\"\"\"\n\nfrom gnuradio import gr\n\
      import pmt\n\nclass blk(gr.sync_block):  # other base classes are basic_block,\
      \ decim_block, interp_block\n    def __init__(self):  # only default arguments\
      \ here\n        \"\"\"arguments to this function show up as parameters in GRC\"\
      \"\"\n        gr.sync_block.__init__(\n            self,\n            name='Custom\
      \ invert',   # will show up in GRC\n            in_sig = None,\n           \
      \ out_sig = None\n        )\n        self.message_port_register_in(pmt.intern('msg_in'))\n\
      \        self.message_port_register_out(pmt.intern('msg_out'))\n        self.set_msg_handler(pmt.intern('msg_in'),\
      \ self.handle_msg)\n\n    def handle_msg(self, msg):\n        data = pmt.to_python(pmt.cdr(msg))\n\
      \        # Perform XOR operation on the odd indexes (bit 1,3,5,...)\n      \
      \  output_data = [byte ^ 1 if i % 2 == 1 else byte for i, byte in enumerate(data)]\n\
      \        self.message_port_pub(pmt.intern('msg_out'), pmt.cons(pmt.PMT_NIL,\
      \ pmt.init_u8vector(len(output_data), output_data)))\n       \n\n\n  "
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
  states:
    _io_cache: ('Custom invert', 'blk', [], [('msg_in', 'message', 1)], [('msg_out',
      'message', 1)], 'arguments to this function show up as parameters in GRC', [])
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [4120, 932.0]
    rotation: 0
    state: disabled
- name: epy_block_3
  id: epy_block
  parameters:
    _source_code: "\"\"\"\nAdd fill bits at the end of the transfer frame to fill\
      \ up 7 bytes for the last BCH codeblock\n\"\"\"\n\nimport numpy as np\nfrom\
      \ gnuradio import gr\nimport pmt\n\nclass blk(gr.basic_block):  # other base\
      \ classes are basic_block, decim_block, interp_bloc\n    # No of data bytes\
      \ for 1 BCH codeblock\n    k = 7\n    def __init__(self):  \n        \"\"\"\
      arguments to this function show up as parameters in GRC\"\"\"\n        gr.basic_block.__init__(\n\
      \            self,\n            name='Custom PDU Add Fill Bits',   # will show\
      \ up in GRC\n            in_sig=None,\n            out_sig=None\n        )\n\
      \        # Register input message passing port \n        self.message_port_register_in(pmt.intern('msg_in'))\n\
      \        # Register output message passing port\n        self.message_port_register_out(pmt.intern('msg_out'))\n\
      \        # Register message handler for input port 'msg_in', ie specify function\
      \ to call when a message is received on input port \n        self.set_msg_handler(pmt.intern('msg_in'),\
      \ self.handle_msg)\n\n    # If the length of the transfer frame is not a multiple\
      \ of 7, add fill bytes until the length is a multiple of 7\n    def handle_msg(self,\
      \ msg): \n        # Convert input message ie pdu to array of bytes\n       \
      \ input_items = np.array(pmt.to_python(pmt.cdr(msg)))\n        # Compute no\
      \ of bytes of fill bits required\n        rem = len(input_items)%self.k\n  \
      \      # Store fill bits required in byte array 'add_items' and concatenate\
      \ to input byte array 'input_items'\n        if (rem != 0):\n            add_items\
      \ = [None]*(self.k-rem)\n            for j in range(self.k-rem):\n         \
      \       add_items[j] = 85 #85 is the decimal representation of '01010101', which\
      \ are the fill bits\n            output_items = np.concatenate((input_items,\
      \ np.array(add_items)))\n        else:\n            output_items = input_items\n\
      \        # Output byte array 'output_items' to port 'msg_out' as a PDU\n   \
      \     self.message_port_pub(pmt.intern('msg_out'), pmt.cons(pmt.PMT_NIL, pmt.init_u8vector(len(output_items),\
      \ output_items)))\n    \n\n        \n"
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
  states:
    _io_cache: ('Custom PDU Add Fill Bits', 'blk', [], [('msg_in', 'message', 1)],
      [('msg_out', 'message', 1)], 'arguments to this function show up as parameters
      in GRC', [])
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1160, 964.0]
    rotation: 0
    state: enabled
- name: epy_block_4_0
  id: epy_block
  parameters:
    _source_code: "\"\"\"\n1. Process TCP messages from upper layer\n2. Process TM\
      \ Transfer Frames to extract CLCW\n3. Frame TC Segment into TC Transfer Frame\n\
      4. Run COP logic\n\"\"\"\n\nimport numpy as np\nfrom gnuradio import gr\nimport\
      \ pmt\nimport struct\nimport math\n\nfrom overall_AbstractFopState import AbstractFopState\n\
      from overall_FopAlertCode import FopAlertCode\nfrom overall_FopDirective import\
      \ FopDirective\nfrom overall_FopEngine import FopEngine\nfrom overall_FopEvent\
      \ import FopEvent\nfrom overall_FopOperationStatus import FopOperationStatus\n\
      from overall_FopState import FopState\nfrom overall_FopStatus import FopStatus\n\
      from overall_IFopObserver import IFopObserver\nfrom overall_TcTransferFrame\
      \ import TcTransferFrame\nfrom overall_Clcw import Clcw\nfrom overall_VirtualChannelAccessMode\
      \ import VirtualChannelAccessMode\nfrom overall_TcSenderVirtualChannel import\
      \ TcSenderVirtualChannel\nfrom overall_BcFrameCollector import BcFrameCollector\n\
      from overall_TransferFrameCollector import TransferFrameCollector\n\n\nclass\
      \ blk(gr.sync_block):  # other base classes are basic_block, decim_block, interp_block\n\
      \    def __init__(self, spacecraft_id_int =80, fecf_present_bool = False, endian_big_or_little\
      \ = \"big\", timer_initial_value=100, transmission_limit=2, timeout_type=0,\
      \ fop_sliding_window=3):  # only default arguments here\n        \"\"\"arguments\
      \ to this function show up as parameters in GRC\"\"\"\n        gr.sync_block.__init__(\n\
      \            self,\n            name='COP Execute',   # will show up in GRC\n\
      \            in_sig=None,\n            out_sig=None\n        )\n        self.spacecraft_id\
      \ = spacecraft_id_int\n        self.fecf_present = fecf_present_bool # Whether\
      \ frame error control field is included in TC transfer frame\n        self.endian\
      \ = endian_big_or_little # Endianess of tcp messages received from/sent to upper\
      \ layer\n        self.timer_initial_value = timer_initial_value # Timeout duration\
      \ in seconds\n        self.transmission_limit = transmission_limit # Maximum\
      \ number of times the first Transfer Frame on the sent_queue may be transmitted\n\
      \        self.timeout_type = timeout_type # Timeout type (0 or 1)\n        self.fop_sliding_window\
      \ = fop_sliding_window # FOP sliding window value (1 to 255)\n        self.segmented\
      \ = False\n        # Input port to receive directives/requests from upper layer\
      \ via TCP\n        self.message_port_register_in(pmt.intern('tcp_in'))\n   \
      \     # Input port to receive TM transfer frames containing CLCWs\n        self.message_port_register_in(pmt.intern('clcw_in'))\n\
      \        # Output port passing transmit data TC Transfer Frames to coding layer\n\
      \        self.message_port_register_out(pmt.intern('data_out'))\n        # Output\
      \ port passing transmit data CLCWs to physical layer\n        self.message_port_register_out(pmt.intern('direct_clcw_out'))\n\
      \        # Output port passing response to upper layer\n        self.message_port_register_out(pmt.intern('response_out'))\n\
      \        # Messages received by 'tcp_in' port will call function 'handle_tcp'\n\
      \        self.set_msg_handler(pmt.intern('tcp_in'), self.handle_tcp)\n     \
      \   # Messages received by 'clcw_in' port will call function 'handle_clcw'\n\
      \        self.set_msg_handler(pmt.intern('clcw_in'), self.handle_clcw)\n   \
      \     # Dictionary to store active Virtual Channels (VC), FOP engines and TC\
      \ frame collectors\n        self.fop_engine_dict = {}      #key = vcid, value\
      \ = [virtual_channel,tc_frame_collector,fop_engine]            \n \n    # Initialise\
      \ TcSenderVirtualChannel\n    def initialise_vc(self, vcid):\n        self.vc_access_mode\
      \ = VirtualChannelAccessMode.DATA\n        virtual_channel = TcSenderVirtualChannel(self.spacecraft_id,vcid,self.vc_access_mode,self.fecf_present,self.segmented)\n\
      \        return virtual_channel\n\n    # Register TransferFrameCollector\n \
      \   def register_tc_collector(self,vc):\n        tc_frame_collector = TransferFrameCollector()\n\
      \        vc.register(tc_frame_collector)\n        return tc_frame_collector\n\
      \n    # Initialise FopEngine\n    def initialise_engine(self, virtual_channel,\
      \ vcid):\n        next_virtual_channel_frame_counter_getter = virtual_channel.get_next_virtual_channel_frame_counter\n\
      \        next_virtual_channel_frame_counter_setter = virtual_channel.set_virtual_channel_frame_counter\n\
      \        bc_frame_collector = BcFrameCollector(virtual_channel)\n        bc_frame_unlock_factory:\
      \ Callable[[int], TcTransferFrame] = bc_frame_collector.get\n        bc_frame_set_vr_factory:\
      \ Callable[[int,int], TcTransferFrame] = bc_frame_collector.apply\n        output:\
      \ Callable[[TcTransferFrame], bool] = self.output\n        fop_engine = FopEngine(vcid,\
      \  #int\n                  next_virtual_channel_frame_counter_getter, #Callable[[],\
      \ int]\n                  next_virtual_channel_frame_counter_setter, #Callable[[int],\
      \ None]\n                  bc_frame_unlock_factory,\n                  bc_frame_set_vr_factory,\n\
      \                  output, #Callable[[TcTransferFrame], bool]\n            \
      \      self.timer_initial_value,\n                  self.transmission_limit,\n\
      \                  self.timeout_type,\n                  self.fop_sliding_window)\n\
      \        # Add observer (listen for responses by fop engine and build TCP messages\
      \ to send to upper layer)\n        self.observer = IFopObserver(self.tcp_server,\
      \ self.endian)\n        fop_engine.register(self.observer)\n        return fop_engine\n\
      \    \n    # Check if VC of a specific VCID is active, activate VC if necessary\
      \ and return a list of [virtual_channel,tc_frame_collector,fop_engine] \n  \
      \  def get_fop_engine(self, vcid):\n        if vcid in self.fop_engine_dict:\n\
      \            return self.fop_engine_dict[vcid]\n        else:\n            vc\
      \ = self.initialise_vc(vcid)\n            tc_frame_collector = self.register_tc_collector(vc)\n\
      \            fop_engine = self.initialise_engine(vc, vcid)\n            self.fop_engine_dict[vcid]\
      \ = [vc,tc_frame_collector,fop_engine]\n            return self.fop_engine_dict[vcid]\n\
      \n    # Output TC transfer frame \n    def output(self, tcframe):\n        tctransferframe_bin\
      \ = tcframe.frame\n        tctransferframe = self.bin_to_int8array(tctransferframe_bin)\n\
      \        self.message_port_pub(pmt.intern('data_out'), pmt.cons(pmt.PMT_NIL,\
      \ pmt.init_u8vector(len(tctransferframe), tctransferframe)))\n        return\
      \ True\n    \n    # Output response\n    def tcp_server(self, msg):\n      \
      \  tcp_msg = self.bin_to_int8array(msg)\n        self.message_port_pub(pmt.intern('response_out'),\
      \ pmt.cons(pmt.PMT_NIL, pmt.init_u8vector(len(tcp_msg), tcp_msg)))\n\n    #\
      \ Extract CLCW from TM transfer frame and pass to fop engine to process\n  \
      \  def handle_clcw(self,msg):\n        self.input_items = np.array(pmt.to_python(pmt.cdr(msg)))\n\
      \        tmframe_byte = bytes(self.input_items)\n        is_clcw = (tmframe_byte[1]\
      \ & 0x01) == 1\n        if (is_clcw):\n            clcw = Clcw(tmframe_byte[-4:])\n\
      \            vcid = clcw.get_virtual_channel_id()\n            print(\"clcw\
      \ received:\",clcw, \" vcid of clcw:\",vcid)\n            fop_engine = self.get_fop_engine(vcid)[2]\n\
      \            if (fop_engine!=None):\n                fop_engine.clcw(clcw)\n\
      \            else:\n                print(\"no fop engine found\")\n       \
      \ else: \n            print(\"tm frame received, no clcw\")\n\n    # Process\
      \ tcp message from upper layer, initialise VC and call fop engine to process\
      \ directives/requests    \n    def handle_tcp(self,msg):\n        self.input_items\
      \ = np.array(pmt.to_python(pmt.cdr(msg)))\n        print(\"tcp_in inputs=\"\
      ,self.int8array_to_int32array(self.input_items))\n        self.req_type = self.toint32(self.input_items[12:16])\
      \ #[3x4:3x4+4]\n        if self.endian == 'big':\n            vcid = self.input_items[19]\
      \  #[4x4]\n        else:\n            vcid = self.input_items[16] \n       \
      \ print(\"vcid:\" ,vcid)\n        self.req_tag = self.toint32(self.input_items[20:24])\
      \ #[5x4:5x4+4]\n        optional_parameter = self.toint32(self.input_items[24:28])\n\
      \n        # Get the VC, fop engine and tc frame collector for that vcid\n  \
      \      dict_value = self.get_fop_engine(vcid)\n        fop_engine = dict_value[2]\n\
      \        virtual_channel = dict_value[0]\n        tc_frame_collector = dict_value[1]\n\
      \n        # Call fop_engine.directive to process directive\n        if 2 <=\
      \ self.req_type <= 12: #ccsds directive request\n            directive = self.case_1()\n\
      \            print(\"Executing directive\", directive)\n            fop_engine.directive(self.req_tag,\
      \ directive, optional_parameter)\n        # Packet data service request (TO\
      \ COMPLETE)\n        elif self.req_type in (60,70): \n            if self.verify_checksum(self.input_items):\n\
      \                self.case_2(virtual_channel,tc_frame_collector, fop_engine)\n\
      \            else: \n                print(\"Wrong checksum\")\n           \
      \     for o in fop_engine.observers:\n                    o.neg_ack_msg()\n\
      \        # Direct TC segment request\n        elif self.req_type in (20,30):\
      \ \n            if self.verify_checksum(self.input_items):\n               \
      \ self.case_3(virtual_channel,tc_frame_collector, fop_engine)\n            else:\
      \ \n                print(\"Wrong checksum\")\n                for o in fop_engine.observers:\n\
      \                    o.neg_ack_msg()\n        # Direct TC transfer frame request\
      \ (TO COMPLETE)\n        elif self.req_type == 50:    \n            if self.verify_checksum(self.input_items):\n\
      \                self.case_4(virtual_channel, fop_engine)\n            else:\
      \ \n                print(\"Wrong checksum\")\n                for o in fop_engine.observers:\n\
      \                    o.neg_ack_msg()\n        # Direct CLTU request (TO COMPLETE)\n\
      \        elif self.req_type == 40: \n            if self.verify_checksum(self.input_items):\n\
      \                self.case_5()\n            else: \n                print(\"\
      Wrong checksum\")\n                for o in fop_engine.observers:\n        \
      \            o.neg_ack_msg()\n        else:\n            self.default_case(fop_engine)\n\
      \n    # Return the respective FOP directive\n    def case_1(self):\n       \
      \ if self.req_type == 2:\n            return FopDirective.INIT_AD_WITHOUT_CLCW\n\
      \        elif self.req_type == 3:\n            return FopDirective.INIT_AD_WITH_CLCW\n\
      \        elif self.req_type == 4:\n            return FopDirective.INIT_AD_WITH_UNLOCK\n\
      \        elif self.req_type == 5:\n            return FopDirective.INIT_AD_WITH_SET_V_R\n\
      \        elif self.req_type == 6:\n            return FopDirective.TERMINATE\n\
      \        elif self.req_type == 7:\n            return FopDirective.RESUME\n\
      \        elif self.req_type == 8:\n            return FopDirective.SET_V_S\n\
      \        elif self.req_type == 9:\n            return FopDirective.SET_FOP_SLIDING_WINDOW\n\
      \        elif self.req_type == 10:\n            return FopDirective.SET_T1_INITIAL\n\
      \        elif self.req_type == 11:\n            return FopDirective.SET_TRANSMISSION_LIMIT\n\
      \        elif self.req_type == 12:\n            return FopDirective.SET_TIMEOUT_TYPE\n\
      \        else:\n            raise ValueError(\"Unsupported directive value\"\
      )\n\n    # Packet data service request (TO COMPLETE)\n    def case_2(self, virtual_channel,tc_frame_collector,\
      \ fop_engine):\n        if (self.req_type == 60): #AD\n            #bypass_flag\
      \ = \"0\"\n            packet_len = self.toint32(self.input_items[24:28]) #packet\
      \ length\n            int8_frame = self.input_items[28:28+packet_len] #packet\
      \ data\n            print(\"in case_2: packet=\",int8_frame)\n            packet\
      \ = self.array_to_binary(int8_frame)\n            # Perform segmentation and\
      \ frame into TC transfer frame(s) and store the frame(s) in tc_frame_collector\n\
      \            virtual_channel.dispatch_data_internal(True,0,packet, self.req_tag,\
      \ self.req_type, True) # ad_mode, map_id, data, req_tag, operation_tag, is_packet\n\
      \            # Retrieve the TC transfer frames one at a time and call fop_engine.transmit\
      \ to process the TC transfer frames until all are transmitted\n            while\
      \ (True):   \n                tcframe = tc_frame_collector.retrieve_first(False)\
      \ \n                if tcframe is None:\n                    break\n       \
      \         print(\"retrieve +1\")\n                response = fop_engine.transmit(tcframe,100)\
      \ #tctransferframe, timeout in ms waiting for acceptance or rejection of the\
      \ request  #return return true if the request was accepted, false it is was\
      \ rejected or the timeout expired\n\n        else: #req_type == 70 #BD\n   \
      \         packet_len = self.toint32(self.input_items[24:28])\n            int8_frame\
      \ = self.input_items[28:28+packet_len] \n            print(\"in case_2: packet=\"\
      ,int8_frame)\n            packet = self.array_to_binary(int8_frame)\n      \
      \      # Perform segmentation and frame into TC transfer frame(s) and store\
      \ the frame(s) in tc_frame_collector\n            virtual_channel.dispatch_data_internal(False,0,packet,\
      \ self.req_tag, self.req_type, True) # ad_mode, map_id, data, req_tag, operation_tag,\
      \ is_packet\n            # Retrieve the TC transfer frames one at a time and\
      \ call fop_engine.transmit to process the TC transfer frames until all are transmitted\n\
      \            while (True):\n                tcframe = tc_frame_collector.retrieve_first(False)\n\
      \                if tcframe is None:\n                    break\n          \
      \      print(\"in case_2: tcframe=\",tcframe)\n                response = fop_engine.transmit(tcframe,100)\
      \ #tctransferframe, timeout in ms waiting for acceptance or rejection of the\
      \ request  #return return true if the request was accepted, false it is was\
      \ rejected or the timeout expired\n\n    # Direct TC segment request       \
      \  \n    def case_3(self, virtual_channel,tc_frame_collector, fop_engine): \n\
      \        #version_no = \"00\"\n        if (self.req_type == 20): #AD\n     \
      \       #bypass_flag = \"0\"\n            segment_len = self.toint32(self.input_items[24:28])\n\
      \            max_length = 1017 if self.fecf_present else 1019\n            if\
      \ (segment_len>max_length):\n                print(\"TC Segment length cannot\
      \ be greater than {max_length}\")\n                for o in fop_engine.observers:\n\
      \                    o.neg_ack_msg()\n            else:\n                int8_frame\
      \ = self.input_items[28:28+segment_len]\n                print(\"TC SEGMENT\
      \ TRANSFER REQUEST(AD): Segment=\",int8_frame)\n                segment = self.array_to_binary(int8_frame)\n\
      \                # Frame into TC transfer frame(s) and store the frame(s) in\
      \ tc_frame_collector\n                virtual_channel.dispatch_data_internal(True,0,segment,\
      \ self.req_tag, self.req_type, False) # ad_mode, map_id, data, req_tag, operation_tag,\
      \ is_packet\n                # Retrieve the TC transfer frames \n          \
      \      tcframe = tc_frame_collector.retrieve_first(True)\n                #\
      \ Call fop_engine.transmit to process the TC transfer frames \n            \
      \    response = fop_engine.transmit(tcframe,100) #tctransferframe, timeout in\
      \ ms waiting for acceptance or rejection of the request  #return return true\
      \ if the request was accepted, false it is was rejected or the timeout expired\n\
      \n        else: #req_type == 30 #BD\n            segment_len = self.toint32(self.input_items[24:28])\n\
      \            max_length = 1017 if self.fecf_present else 1019\n            if\
      \ (segment_len>max_length):\n                print(\"TC Segment length cannot\
      \ be greater than {max_length}\")\n                for o in fop_engine.observers:\n\
      \                    o.neg_ack_msg()\n            else:\n                int8_frame\
      \ = self.input_items[28:28+segment_len] \n                print(\"TC SEGMENT\
      \ TRANSFER REQUEST(BD): Segment=\",int8_frame)\n                segment = self.array_to_binary(int8_frame)\n\
      \                # Frame into TC transfer frame(s) and store the frame(s) in\
      \ tc_frame_collector\n                virtual_channel.dispatch_data_internal(False,0,segment,\
      \ self.req_tag, self.req_type, False) # ad_mode, map_id, data, req_tag, operation_tag,\
      \ is_packet\n                # Retrieve the TC transfer frames \n          \
      \      tcframe = tc_frame_collector.retrieve_first(True)\n                #\
      \ Call fop_engine.transmit to process the TC transfer frames \n            \
      \    response = fop_engine.transmit(tcframe,100) #tctransferframe, timeout in\
      \ ms waiting for acceptance or rejection of the request  #return return true\
      \ if the request was accepted, false it is was rejected or the timeout expired\n\
      \n    # Direct TC transfer frame request (TO COMPLETE- receive and process positive/negative\
      \ ack)        \n    def case_4(self, virtual_channel, fop_engine):\n       \
      \ frame_len = self.toint32(self.input_items[24:28])\n        int8_frame = self.input_items[28:28+frame_len]\
      \ #[7x4:-2x4]\n        print(\"in case_4: int_frame=\",int8_frame)\n       \
      \ frame = self.array_to_binary(int8_frame)\n        # Convert tc transfer frame\
      \ from int8 array to TcTransferFrame object\n        tcframe = TcTransferFrame(frame,\
      \ False, self.fecf_present, req_tag=self.req_tag, operation_tag=self.req_type)\
      \  #frame, segmented, fecf_present, sec_header_length=0, sec_trailer_length=0\n\
      \        seq_no = int8_frame[4]\n        print(\"seq no=\", seq_no)\n      \
      \  print(\"v(s)=\",virtual_channel.get_next_virtual_channel_frame_counter())\n\
      \        # Check if the frame seq no of transfer frame match with V(S), if yes\
      \ then increment V(S) and output TC transfer frame\n        if (seq_no == virtual_channel.get_next_virtual_channel_frame_counter()):\n\
      \            virtual_channel.increment_virtual_channel_frame_counter(256)\n\
      \            response = self.output(tcframe)\n            for o in fop_engine.observers:\n\
      \                o.transfer_notification(fop_engine, FopOperationStatus.ACCEPT_RESPONSE\
      \ if response == True else FopOperationStatus.REJECT_RESPONSE, tcframe)\n  \
      \      else: # Wrong frame seq no \n            for o in fop_engine.observers:\n\
      \                o.neg_ack_msg()\n\n    # Direct CLTU request (TO COMPLETE-\
      \ receive and process positive/negative ack)  \n    def case_5(self):\n    \
      \    print(\"Case 5 is executed.\")\n        clcw_len = self.toint32(self.input_items[24:28])\n\
      \        clcw = self.input_items[28:28+clcw_len]\n        self.message_port_pub(pmt.intern('direct_clcw_out'),\
      \ pmt.cons(pmt.PMT_NIL, pmt.init_u8vector(len(clcw), clcw)))\n\n    def default_case(self,\
      \ fop_engine):\n        print(\"Default case is executed.\")\n        for o\
      \ in fop_engine.observers:\n            o.neg_ack_msg()\n\n    # Get the data\
      \ frame (Packet/Segment/Transfer frame/CLTU) in big endian from the TCP message\n\
      \    def get_tc_data(self,data_len):\n        if self.endian == 'big':\n   \
      \         return self.input_items[28:28+data_len]\n        else:\n         \
      \   int8_array = self.input_items[28:28+math.ceil(data_len/4)*4]\n         \
      \   int32_array = self.int8array_to_int32array(int8_array)\n            int8_array_big\
      \ = []\n            for value in int32_array:\n                int8_array_big.extend(struct.unpack('>4B',\
      \ struct.pack('>I', value)))\n            if data_len%4 == 0:\n            \
      \    return int8_array_big\n            return int8_array_big[:data_len%4-4]\n\
      \n    # Convert int8 array to binary \n    def array_to_binary(self,int8_array):\n\
      \        binary_data = b''\n        for value in int8_array:\n            binary_data\
      \ += struct.pack('>B', value) #unsigned int8  \n        return binary_data\n\
      \n    # Convert binary to int8 array   \n    def bin_to_int8array(self,binary_data):\n\
      \        int8_array = [int(byte) for byte in binary_data] #unsigned int8\n \
      \       return int8_array\n        \n    # Convert int8 array to int32 array\
      \ \n    def int8array_to_int32array(self,int8_array):\n        int32_array =\
      \ [int.from_bytes(int8_array[i:i+4], self.endian, signed=True) for i in range(0,\
      \ len(int8_array), 4)]\n        return int32_array \n\n    # Convert 4 element\
      \ int8 array to int32 \n    def toint32(self,int8_array):\n        byte_data\
      \ = bytes(int8_array)  #unsigned as gnuradio int8 is unsigned\n        # Convert\
      \ bytes to integer\n        int32_value = int.from_bytes(byte_data, byteorder=self.endian,\
      \ signed=True) \n        return int32_value\n    \n    # Convert binary to int32\
      \ array\n    def binary_to_int32array(self,byte_data):\n        int32_array\
      \ = []\n        step = 4  # 4 bytes per 32-bit integer\n        fmt = '>' if\
      \ self.endian == 'big' else '<'\n        for i in range(0, len(byte_data), step):\n\
      \            int32_value = struct.unpack(fmt + 'i', byte_data[i:i+step])[0]\n\
      \            int32_array.append(int32_value)\n        return int32_array\n\n\
      \    # Verify checksum of TCP message\n    def verify_checksum(self,input_items):\n\
      \        # Convert int8 array to binary\n        received_packet = self.array_to_binary(input_items)\n\
      \        # Split the packet data and the checksum\n        packet_data = received_packet[:-8]\
      \ + received_packet[-4:]\n        received_checksum = received_packet[-8:-4]\n\
      \        # Convert the received checksum to an unsigned 32-bit integer\n   \
      \     if self.endian == 'big':\n            received_checksum = struct.unpack('>I',\
      \ received_checksum)[0]  # '>I' for big-endian unsigned int32\n        else:\n\
      \            received_checksum = struct.unpack('<I', received_checksum)[0] \
      \ # '<I' for little-endian unsigned int32\n        # Convert the packet data\
      \ back to a list of signed 32-bit integers\n        int32_packet = self.binary_to_int32array(packet_data)\n\
      \        calculated_checksum = self.calculate_checksum(int32_packet)\n     \
      \   return calculated_checksum == received_checksum\n    \n    # Calculate 2s\
      \ complement 32 bit checksum for the TCP message \n    def calculate_checksum(self,\
      \ packet):\n        # Initialize the checksum\n        checksum = 0\n      \
      \  # Sum up all the 32-bit words in the packet\n        for word in packet:\n\
      \            checksum += word\n        # Take the one's complement\n       \
      \ checksum = ~checksum\n        # Add 1 to the one's complement result\n   \
      \     checksum += 1\n        # Take the result modulo 2^32\n        checksum\
      \ &= 0xFFFFFFFF\n        return checksum"
    affinity: ''
    alias: ''
    comment: ''
    endian_big_or_little: '''big'''
    fecf_present_bool: 'False'
    fop_sliding_window: '3'
    maxoutbuf: '0'
    minoutbuf: '0'
    spacecraft_id_int: '80'
    timeout_type: '0'
    timer_initial_value: '100'
    transmission_limit: '2'
  states:
    _io_cache: ('COP Execute', 'blk', [('spacecraft_id_int', '80'), ('fecf_present_bool',
      'False'), ('endian_big_or_little', "'big'"), ('timer_initial_value', '100'),
      ('transmission_limit', '2'), ('timeout_type', '0'), ('fop_sliding_window', '3')],
      [('tcp_in', 'message', 1), ('clcw_in', 'message', 1)], [('response_out', 'message',
      1), ('direct_clcw_out', 'message', 1), ('data_out', 'message', 1)], 'arguments
      to this function show up as parameters in GRC', ['fop_sliding_window', 'timeout_type',
      'timer_initial_value', 'transmission_limit'])
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [408, 900.0]
    rotation: 0
    state: disabled
- name: epy_block_5_0
  id: epy_block
  parameters:
    _source_code: "\"\"\"\nAdd Start and Tail sequence to frame into a CLCW \n\"\"\
      \"\n\nimport numpy as np\nfrom gnuradio import gr\nimport pmt\n\nclass blk(gr.basic_block):\
      \  # other base classes are basic_block, decim_block, interp_block\n    def\
      \ __init__(self):  # only default arguments here\n        \"\"\"arguments to\
      \ this function show up as parameters in GRC\"\"\"\n        gr.basic_block.__init__(\n\
      \            self,\n            name='Custom PDU Add Start/Stop Seq',   # will\
      \ show up in GRC\n            in_sig=None,\n            out_sig=None\n     \
      \   )\n        # Register input message passing port \n        self.message_port_register_in(pmt.intern('msg_in'))\n\
      \        # Register output message passing port\n        self.message_port_register_out(pmt.intern('msg_out'))\n\
      \        # Register message handler for input port 'msg_in', ie specify function\
      \ to call when a message is received on input port \n        self.set_msg_handler(pmt.intern('msg_in'),\
      \ self.handle_msg)\n\n    # Add the start_seq and stop_seq to the start and\
      \ end of the packet respectively\n    def handle_msg(self, msg): \n        start_seq\
      \ = np.array([int(\"11101011\",2),int(\"10010000\",2)])\n        stop_seq =\
      \ np.array([int(\"C5\",16),int(\"C5\",16),int(\"C5\",16),int(\"C5\",16),int(\"\
      C5\",16),int(\"C5\",16),int(\"C5\",16),int(\"79\",16)])\n        data = np.concatenate((start_seq,\
      \ np.array(pmt.to_python(pmt.cdr(msg))),stop_seq))\n        self.message_port_pub(pmt.intern('msg_out'),\
      \ pmt.cons(pmt.PMT_NIL, pmt.init_u8vector(len(data), data)))"
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
  states:
    _io_cache: ('Custom PDU Add Start/Stop Seq', 'blk', [], [('msg_in', 'message',
      1)], [('msg_out', 'message', 1)], 'arguments to this function show up as parameters
      in GRC', [])
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1864, 964.0]
    rotation: 0
    state: enabled
- name: iio_pluto_sink_0_0
  id: iio_pluto_sink
  parameters:
    affinity: ''
    alias: ''
    attenuation1: '10.0'
    bandwidth: '20000000'
    buffer_size: '32768'
    comment: ''
    cyclic: 'False'
    filter: ''
    filter_source: '''Auto'''
    fpass: '0'
    frequency: '2400000000'
    fstop: '0'
    len_tag_key: ''
    samplerate: samp_rate
    type: fc32
    uri: ip:192.168.2.1
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1744, 1436.0]
    rotation: 0
    state: disabled
- name: iio_pluto_sink_0_0_0
  id: iio_pluto_sink
  parameters:
    affinity: ''
    alias: ''
    attenuation1: '10.0'
    bandwidth: '20000000'
    buffer_size: '32768'
    comment: ''
    cyclic: 'False'
    filter: ''
    filter_source: '''Auto'''
    fpass: '0'
    frequency: '2400000000'
    fstop: '0'
    len_tag_key: ''
    samplerate: samp_rate
    type: fc32
    uri: ip:192.168.2.1
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [3824, 1444.0]
    rotation: 0
    state: disabled
- name: iio_pluto_source_0
  id: iio_pluto_source
  parameters:
    affinity: ''
    alias: ''
    bandwidth: '20000000'
    bbdc: 'True'
    buffer_size: '32768'
    comment: ''
    filter: ''
    filter_source: '''Auto'''
    fpass: '0'
    frequency: '2400000000'
    fstop: '0'
    gain1: '''slow_attack'''
    len_tag_key: packet_len
    manual_gain1: '64'
    maxoutbuf: '0'
    minoutbuf: '0'
    quadrature: 'True'
    rfdc: 'True'
    samplerate: samp_rate
    type: fc32
    uri: ip:192.168.2.1
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [176, 2084.0]
    rotation: 0
    state: disabled
- name: iio_pluto_source_0_1
  id: iio_pluto_source
  parameters:
    affinity: ''
    alias: ''
    bandwidth: '20000000'
    bbdc: 'True'
    buffer_size: '32768'
    comment: ''
    filter: ''
    filter_source: '''Auto'''
    fpass: '0'
    frequency: '2400000000'
    fstop: '0'
    gain1: '''slow_attack'''
    len_tag_key: packet_len
    manual_gain1: '64'
    maxoutbuf: '0'
    minoutbuf: '0'
    quadrature: 'True'
    rfdc: 'True'
    samplerate: samp_rate
    type: fc32
    uri: ip:192.168.2.1
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [2712, 2060.0]
    rotation: 0
    state: disabled
- name: network_socket_pdu_0
  id: network_socket_pdu
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    host: localhost
    maxoutbuf: '0'
    minoutbuf: '0'
    mtu: '10000'
    port: '3070'
    tcp_no_delay: 'False'
    type: TCP_SERVER
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [4560, 2184.0]
    rotation: 0
    state: enabled
- name: network_socket_pdu_0_0
  id: network_socket_pdu
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    host: localhost
    maxoutbuf: '0'
    minoutbuf: '0'
    mtu: '10000'
    port: '3020'
    tcp_no_delay: 'False'
    type: TCP_SERVER
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [96, 1048.0]
    rotation: 0
    state: enabled
- name: network_socket_pdu_0_3
  id: network_socket_pdu
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    host: localhost
    maxoutbuf: '0'
    minoutbuf: '0'
    mtu: '10000'
    port: '2002'
    tcp_no_delay: 'False'
    type: TCP_SERVER
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [96, 824.0]
    rotation: 0
    state: enabled
- name: pdu_pdu_to_tagged_stream_0_0
  id: pdu_pdu_to_tagged_stream
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    tag: packet_len
    type: byte
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [536, 1300.0]
    rotation: 0
    state: enabled
- name: pdu_pdu_to_tagged_stream_0_0_1
  id: pdu_pdu_to_tagged_stream
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    tag: packet_len
    type: byte
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [4128, 1028.0]
    rotation: 0
    state: disabled
- name: pdu_pdu_to_tagged_stream_0_1
  id: pdu_pdu_to_tagged_stream
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    tag: packet_len
    type: byte
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [3384, 1140.0]
    rotation: 0
    state: disabled
- name: pdu_tagged_stream_to_pdu_0
  id: pdu_tagged_stream_to_pdu
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    tag: packet_len
    type: byte
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1688, 132.0]
    rotation: 0
    state: disabled
- name: pdu_tagged_stream_to_pdu_0_0
  id: pdu_tagged_stream_to_pdu
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    tag: packet_len
    type: byte
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [3760, 1044.0]
    rotation: 0
    state: disabled
- name: pdu_tagged_stream_to_pdu_1
  id: pdu_tagged_stream_to_pdu
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    tag: packet_len
    type: byte
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [3024, 1156.0]
    rotation: 0
    state: disabled
- name: qtgui_const_sink_x_0_0
  id: qtgui_const_sink_x
  parameters:
    affinity: ''
    alias: ''
    alpha1: '1.0'
    alpha10: '1.0'
    alpha2: '1.0'
    alpha3: '1.0'
    alpha4: '1.0'
    alpha5: '1.0'
    alpha6: '1.0'
    alpha7: '1.0'
    alpha8: '1.0'
    alpha9: '1.0'
    autoscale: 'False'
    axislabels: 'True'
    color1: '"blue"'
    color10: '"red"'
    color2: '"red"'
    color3: '"red"'
    color4: '"red"'
    color5: '"red"'
    color6: '"red"'
    color7: '"red"'
    color8: '"red"'
    color9: '"red"'
    comment: ''
    grid: 'False'
    gui_hint: ''
    label1: ''
    label10: ''
    label2: ''
    label3: ''
    label4: ''
    label5: ''
    label6: ''
    label7: ''
    label8: ''
    label9: ''
    legend: 'True'
    marker1: '0'
    marker10: '0'
    marker2: '0'
    marker3: '0'
    marker4: '0'
    marker5: '0'
    marker6: '0'
    marker7: '0'
    marker8: '0'
    marker9: '0'
    name: '"Output"'
    nconnections: '1'
    size: '1024'
    style1: '0'
    style10: '0'
    style2: '0'
    style3: '0'
    style4: '0'
    style5: '0'
    style6: '0'
    style7: '0'
    style8: '0'
    style9: '0'
    tr_chan: '0'
    tr_level: '0.0'
    tr_mode: qtgui.TRIG_MODE_FREE
    tr_slope: qtgui.TRIG_SLOPE_POS
    tr_tag: '""'
    type: complex
    update_time: '0.10'
    width1: '1'
    width10: '1'
    width2: '1'
    width3: '1'
    width4: '1'
    width5: '1'
    width6: '1'
    width7: '1'
    width8: '1'
    width9: '1'
    xmax: '2'
    xmin: '-2'
    ymax: '2'
    ymin: '-2'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1360, 2020.0]
    rotation: 0
    state: enabled
- name: qtgui_freq_sink_x_0
  id: qtgui_freq_sink_x
  parameters:
    affinity: ''
    alias: ''
    alpha1: '1.0'
    alpha10: '1.0'
    alpha2: '1.0'
    alpha3: '1.0'
    alpha4: '1.0'
    alpha5: '1.0'
    alpha6: '1.0'
    alpha7: '1.0'
    alpha8: '1.0'
    alpha9: '1.0'
    autoscale: 'False'
    average: '1.0'
    axislabels: 'True'
    bw: samp_rate
    color1: '"blue"'
    color10: '"dark blue"'
    color2: '"red"'
    color3: '"green"'
    color4: '"black"'
    color5: '"cyan"'
    color6: '"magenta"'
    color7: '"yellow"'
    color8: '"dark red"'
    color9: '"dark green"'
    comment: ''
    ctrlpanel: 'False'
    fc: '0'
    fftsize: '1024'
    freqhalf: 'True'
    grid: 'False'
    gui_hint: ''
    label: Relative Gain
    label1: ''
    label10: ''
    label2: ''
    label3: ''
    label4: ''
    label5: ''
    label6: ''
    label7: ''
    label8: ''
    label9: ''
    legend: 'True'
    maxoutbuf: '0'
    minoutbuf: '0'
    name: '"Input"'
    nconnections: '1'
    norm_window: 'False'
    showports: 'True'
    tr_chan: '0'
    tr_level: '0.0'
    tr_mode: qtgui.TRIG_MODE_FREE
    tr_tag: '""'
    type: complex
    units: dB
    update_time: '0.10'
    width1: '1'
    width10: '1'
    width2: '1'
    width3: '1'
    width4: '1'
    width5: '1'
    width6: '1'
    width7: '1'
    width8: '1'
    width9: '1'
    wintype: window.WIN_BLACKMAN_hARRIS
    ymax: '10'
    ymin: '-140'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1728, 1264.0]
    rotation: 0
    state: enabled
- name: qtgui_freq_sink_x_0_0
  id: qtgui_freq_sink_x
  parameters:
    affinity: ''
    alias: ''
    alpha1: '1.0'
    alpha10: '1.0'
    alpha2: '1.0'
    alpha3: '1.0'
    alpha4: '1.0'
    alpha5: '1.0'
    alpha6: '1.0'
    alpha7: '1.0'
    alpha8: '1.0'
    alpha9: '1.0'
    autoscale: 'False'
    average: '1.0'
    axislabels: 'True'
    bw: samp_rate
    color1: '"blue"'
    color10: '"dark blue"'
    color2: '"red"'
    color3: '"green"'
    color4: '"black"'
    color5: '"cyan"'
    color6: '"magenta"'
    color7: '"yellow"'
    color8: '"dark red"'
    color9: '"dark green"'
    comment: ''
    ctrlpanel: 'False'
    fc: '0'
    fftsize: '1024'
    freqhalf: 'True'
    grid: 'False'
    gui_hint: ''
    label: Relative Gain
    label1: ''
    label10: ''
    label2: ''
    label3: ''
    label4: ''
    label5: ''
    label6: ''
    label7: ''
    label8: ''
    label9: ''
    legend: 'True'
    maxoutbuf: '0'
    minoutbuf: '0'
    name: '"Ouput freq"'
    nconnections: '1'
    norm_window: 'False'
    showports: 'True'
    tr_chan: '0'
    tr_level: '0.0'
    tr_mode: qtgui.TRIG_MODE_FREE
    tr_tag: '""'
    type: complex
    units: dB
    update_time: '0.10'
    width1: '1'
    width10: '1'
    width2: '1'
    width3: '1'
    width4: '1'
    width5: '1'
    width6: '1'
    width7: '1'
    width8: '1'
    width9: '1'
    wintype: window.WIN_BLACKMAN_hARRIS
    ymax: '10'
    ymin: '-140'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [568, 2312.0]
    rotation: 0
    state: enabled
- name: qtgui_freq_sink_x_0_0_0
  id: qtgui_freq_sink_x
  parameters:
    affinity: ''
    alias: ''
    alpha1: '1.0'
    alpha10: '1.0'
    alpha2: '1.0'
    alpha3: '1.0'
    alpha4: '1.0'
    alpha5: '1.0'
    alpha6: '1.0'
    alpha7: '1.0'
    alpha8: '1.0'
    alpha9: '1.0'
    autoscale: 'False'
    average: '1.0'
    axislabels: 'True'
    bw: samp_rate
    color1: '"blue"'
    color10: '"dark blue"'
    color2: '"red"'
    color3: '"green"'
    color4: '"black"'
    color5: '"cyan"'
    color6: '"magenta"'
    color7: '"yellow"'
    color8: '"dark red"'
    color9: '"dark green"'
    comment: ''
    ctrlpanel: 'False'
    fc: '0'
    fftsize: '1024'
    freqhalf: 'True'
    grid: 'False'
    gui_hint: ''
    label: Relative Gain
    label1: ''
    label10: ''
    label2: ''
    label3: ''
    label4: ''
    label5: ''
    label6: ''
    label7: ''
    label8: ''
    label9: ''
    legend: 'True'
    maxoutbuf: '0'
    minoutbuf: '0'
    name: '"Ouput freq"'
    nconnections: '1'
    norm_window: 'False'
    showports: 'True'
    tr_chan: '0'
    tr_level: '0.0'
    tr_mode: qtgui.TRIG_MODE_FREE
    tr_tag: '""'
    type: complex
    units: dB
    update_time: '0.10'
    width1: '1'
    width10: '1'
    width2: '1'
    width3: '1'
    width4: '1'
    width5: '1'
    width6: '1'
    width7: '1'
    width8: '1'
    width9: '1'
    wintype: window.WIN_BLACKMAN_hARRIS
    ymax: '10'
    ymin: '-140'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [3184, 2504.0]
    rotation: 0
    state: enabled
- name: qtgui_time_sink_x_0
  id: qtgui_time_sink_x
  parameters:
    affinity: ''
    alias: ''
    alpha1: '1.0'
    alpha10: '1.0'
    alpha2: '1.0'
    alpha3: '1.0'
    alpha4: '1.0'
    alpha5: '1.0'
    alpha6: '1.0'
    alpha7: '1.0'
    alpha8: '1.0'
    alpha9: '1.0'
    autoscale: 'False'
    axislabels: 'True'
    color1: blue
    color10: dark blue
    color2: red
    color3: green
    color4: black
    color5: cyan
    color6: magenta
    color7: yellow
    color8: dark red
    color9: dark green
    comment: ''
    ctrlpanel: 'False'
    entags: 'True'
    grid: 'False'
    gui_hint: ''
    label1: ''
    label10: ''
    label2: ''
    label3: ''
    label4: ''
    label5: ''
    label6: ''
    label7: ''
    label8: ''
    label9: ''
    legend: 'True'
    marker1: '-1'
    marker10: '-1'
    marker2: '-1'
    marker3: '-1'
    marker4: '-1'
    marker5: '-1'
    marker6: '-1'
    marker7: '-1'
    marker8: '-1'
    marker9: '-1'
    name: '"Uplink output before demod"'
    nconnections: '1'
    size: '1024'
    srate: samp_rate
    stemplot: 'False'
    style1: '1'
    style10: '1'
    style2: '1'
    style3: '1'
    style4: '1'
    style5: '1'
    style6: '1'
    style7: '1'
    style8: '1'
    style9: '1'
    tr_chan: '0'
    tr_delay: '0'
    tr_level: '0.0'
    tr_mode: qtgui.TRIG_MODE_FREE
    tr_slope: qtgui.TRIG_SLOPE_POS
    tr_tag: '""'
    type: complex
    update_time: '0.10'
    width1: '1'
    width10: '1'
    width2: '1'
    width3: '1'
    width4: '1'
    width5: '1'
    width6: '1'
    width7: '1'
    width8: '1'
    width9: '1'
    ylabel: Amplitude
    ymax: '2'
    ymin: '-2'
    yunit: '""'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [568, 2480.0]
    rotation: 0
    state: enabled
- name: qtgui_time_sink_x_0_0
  id: qtgui_time_sink_x
  parameters:
    affinity: ''
    alias: ''
    alpha1: '1.0'
    alpha10: '1.0'
    alpha2: '1.0'
    alpha3: '1.0'
    alpha4: '1.0'
    alpha5: '1.0'
    alpha6: '1.0'
    alpha7: '1.0'
    alpha8: '1.0'
    alpha9: '1.0'
    autoscale: 'False'
    axislabels: 'True'
    color1: blue
    color10: dark blue
    color2: red
    color3: green
    color4: black
    color5: cyan
    color6: magenta
    color7: yellow
    color8: dark red
    color9: dark green
    comment: ''
    ctrlpanel: 'False'
    entags: 'True'
    grid: 'False'
    gui_hint: ''
    label1: ''
    label10: ''
    label2: ''
    label3: ''
    label4: ''
    label5: ''
    label6: ''
    label7: ''
    label8: ''
    label9: ''
    legend: 'True'
    marker1: '-1'
    marker10: '-1'
    marker2: '-1'
    marker3: '-1'
    marker4: '-1'
    marker5: '-1'
    marker6: '-1'
    marker7: '-1'
    marker8: '-1'
    marker9: '-1'
    name: '"Downlink output before demod"'
    nconnections: '1'
    size: '1024'
    srate: samp_rate
    stemplot: 'False'
    style1: '1'
    style10: '1'
    style2: '1'
    style3: '1'
    style4: '1'
    style5: '1'
    style6: '1'
    style7: '1'
    style8: '1'
    style9: '1'
    tr_chan: '0'
    tr_delay: '0'
    tr_level: '0.0'
    tr_mode: qtgui.TRIG_MODE_FREE
    tr_slope: qtgui.TRIG_SLOPE_POS
    tr_tag: '""'
    type: complex
    update_time: '0.10'
    width1: '1'
    width10: '1'
    width2: '1'
    width3: '1'
    width4: '1'
    width5: '1'
    width6: '1'
    width7: '1'
    width8: '1'
    width9: '1'
    ylabel: Amplitude
    ymax: '2'
    ymin: '-2'
    yunit: '""'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [3176, 2344.0]
    rotation: 0
    state: enabled
- name: qtgui_time_sink_x_0_1
  id: qtgui_time_sink_x
  parameters:
    affinity: ''
    alias: ''
    alpha1: '1.0'
    alpha10: '1.0'
    alpha2: '1.0'
    alpha3: '1.0'
    alpha4: '1.0'
    alpha5: '1.0'
    alpha6: '1.0'
    alpha7: '1.0'
    alpha8: '1.0'
    alpha9: '1.0'
    autoscale: 'False'
    axislabels: 'True'
    color1: blue
    color10: dark blue
    color2: red
    color3: green
    color4: black
    color5: cyan
    color6: magenta
    color7: yellow
    color8: dark red
    color9: dark green
    comment: ''
    ctrlpanel: 'False'
    entags: 'True'
    grid: 'False'
    gui_hint: ''
    label1: Signal 1
    label10: Signal 10
    label2: Signal 2
    label3: Signal 3
    label4: Signal 4
    label5: Signal 5
    label6: Signal 6
    label7: Signal 7
    label8: Signal 8
    label9: Signal 9
    legend: 'True'
    marker1: '-1'
    marker10: '-1'
    marker2: '-1'
    marker3: '-1'
    marker4: '-1'
    marker5: '-1'
    marker6: '-1'
    marker7: '-1'
    marker8: '-1'
    marker9: '-1'
    name: '"Downlink input after mod"'
    nconnections: '1'
    size: '1024'
    srate: samp_rate
    stemplot: 'False'
    style1: '1'
    style10: '1'
    style2: '1'
    style3: '1'
    style4: '1'
    style5: '1'
    style6: '1'
    style7: '1'
    style8: '1'
    style9: '1'
    tr_chan: '0'
    tr_delay: '0'
    tr_level: '0.0'
    tr_mode: qtgui.TRIG_MODE_FREE
    tr_slope: qtgui.TRIG_SLOPE_POS
    tr_tag: '""'
    type: complex
    update_time: '0.10'
    width1: '1'
    width10: '1'
    width2: '1'
    width3: '1'
    width4: '1'
    width5: '1'
    width6: '1'
    width7: '1'
    width8: '1'
    width9: '1'
    ylabel: Amplitude
    ymax: '1'
    ymin: '-1'
    yunit: '""'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [3832, 1272.0]
    rotation: 0
    state: enabled
- name: qtgui_time_sink_x_1
  id: qtgui_time_sink_x
  parameters:
    affinity: ''
    alias: ''
    alpha1: '1.0'
    alpha10: '1.0'
    alpha2: '1.0'
    alpha3: '1.0'
    alpha4: '1.0'
    alpha5: '1.0'
    alpha6: '1.0'
    alpha7: '1.0'
    alpha8: '1.0'
    alpha9: '1.0'
    autoscale: 'False'
    axislabels: 'True'
    color1: blue
    color10: dark blue
    color2: red
    color3: green
    color4: black
    color5: cyan
    color6: magenta
    color7: yellow
    color8: dark red
    color9: dark green
    comment: ''
    ctrlpanel: 'True'
    entags: 'True'
    grid: 'False'
    gui_hint: ''
    label1: ''
    label10: ''
    label2: ''
    label3: ''
    label4: ''
    label5: ''
    label6: ''
    label7: ''
    label8: ''
    label9: ''
    legend: 'True'
    marker1: '-1'
    marker10: '-1'
    marker2: '-1'
    marker3: '-1'
    marker4: '-1'
    marker5: '-1'
    marker6: '-1'
    marker7: '-1'
    marker8: '-1'
    marker9: '-1'
    name: '"Uplink input after mod"'
    nconnections: '1'
    size: '1024'
    srate: samp_rate
    stemplot: 'False'
    style1: '1'
    style10: '1'
    style2: '1'
    style3: '1'
    style4: '1'
    style5: '1'
    style6: '1'
    style7: '1'
    style8: '1'
    style9: '1'
    tr_chan: '0'
    tr_delay: '0'
    tr_level: '0.0'
    tr_mode: qtgui.TRIG_MODE_FREE
    tr_slope: qtgui.TRIG_SLOPE_POS
    tr_tag: '""'
    type: complex
    update_time: '0.10'
    width1: '1'
    width10: '1'
    width2: '1'
    width3: '1'
    width4: '1'
    width5: '1'
    width6: '1'
    width7: '1'
    width8: '1'
    width9: '1'
    ylabel: Amplitude
    ymax: '2'
    ymin: '-2'
    yunit: '""'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1728, 1112.0]
    rotation: 0
    state: enabled
- name: qtgui_time_sink_x_2
  id: qtgui_time_sink_x
  parameters:
    affinity: ''
    alias: ''
    alpha1: '1.0'
    alpha10: '1.0'
    alpha2: '1.0'
    alpha3: '1.0'
    alpha4: '1.0'
    alpha5: '1.0'
    alpha6: '1.0'
    alpha7: '1.0'
    alpha8: '1.0'
    alpha9: '1.0'
    autoscale: 'False'
    axislabels: 'True'
    color1: blue
    color10: dark blue
    color2: red
    color3: green
    color4: black
    color5: cyan
    color6: magenta
    color7: yellow
    color8: dark red
    color9: dark green
    comment: ''
    ctrlpanel: 'False'
    entags: 'True'
    grid: 'False'
    gui_hint: ''
    label1: ''
    label10: ''
    label2: ''
    label3: ''
    label4: ''
    label5: ''
    label6: ''
    label7: ''
    label8: ''
    label9: ''
    legend: 'True'
    marker1: '-1'
    marker10: '-1'
    marker2: '-1'
    marker3: '-1'
    marker4: '-1'
    marker5: '-1'
    marker6: '-1'
    marker7: '-1'
    marker8: '-1'
    marker9: '-1'
    name: '"Uplink demodulated Output"'
    nconnections: '1'
    size: '1024'
    srate: samp_rate
    stemplot: 'False'
    style1: '1'
    style10: '1'
    style2: '1'
    style3: '1'
    style4: '1'
    style5: '1'
    style6: '1'
    style7: '1'
    style8: '1'
    style9: '1'
    tr_chan: '0'
    tr_delay: '0'
    tr_level: '0.0'
    tr_mode: qtgui.TRIG_MODE_FREE
    tr_slope: qtgui.TRIG_SLOPE_POS
    tr_tag: '""'
    type: float
    update_time: '0.10'
    width1: '1'
    width10: '1'
    width2: '1'
    width3: '1'
    width4: '1'
    width5: '1'
    width6: '1'
    width7: '1'
    width8: '1'
    width9: '1'
    ylabel: Amplitude
    ymax: '2'
    ymin: '-2'
    yunit: '""'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1936, 2152.0]
    rotation: 0
    state: enabled
- name: satellites_ccsds_concatenated_deframer_1_0
  id: satellites_ccsds_concatenated_deframer
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    convolutional: '"CCSDS"'
    frame_size: '223'
    maxoutbuf: '0'
    minoutbuf: '0'
    options: '""'
    precoding: None
    rs_basis: '"conventional"'
    rs_interleaving: '1'
    scrambler: '"none"'
    threshold: '4'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [4144, 2152.0]
    rotation: 0
    state: enabled
- name: satellites_convolutional_encoder_1_0
  id: satellites_convolutional_encoder
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    constraint: '7'
    maxoutbuf: '0'
    minoutbuf: '0'
    polynomials: '[79,109]'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [3760, 1128.0]
    rotation: 0
    state: disabled
- name: satellites_encode_rs_ccsds_0_0
  id: satellites_encode_rs_ccsds
  parameters:
    affinity: ''
    alias: ''
    basis: 'False'
    comment: ''
    interleave: '1'
    maxoutbuf: '0'
    minoutbuf: '0'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [3360, 952.0]
    rotation: 0
    state: disabled
- name: satellites_hexdump_sink_0
  id: satellites_hexdump_sink
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    options: '""'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [2368, 976.0]
    rotation: 0
    state: disabled
- name: satellites_hexdump_sink_0_0
  id: satellites_hexdump_sink
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    options: '""'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [824, 872.0]
    rotation: 0
    state: disabled
- name: satellites_hexdump_sink_1
  id: satellites_hexdump_sink
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    options: '""'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [4568, 2088.0]
    rotation: 0
    state: disabled

connections:
- [analog_noise_source_x_0, '0', blocks_add_xx_0_0, '1']
- [analog_noise_source_x_0_0, '0', blocks_add_xx_0_0_0, '1']
- [blocks_add_xx_0_0, '0', blocks_file_sink_2, '0']
- [blocks_add_xx_0_0, '0', digital_pfb_clock_sync_xxx_0_0_0, '0']
- [blocks_add_xx_0_0, '0', qtgui_freq_sink_x_0_0_0, '0']
- [blocks_add_xx_0_0, '0', qtgui_time_sink_x_0_0, '0']
- [blocks_add_xx_0_0_0, '0', digital_pfb_clock_sync_xxx_0, '0']
- [blocks_add_xx_0_0_0, '0', qtgui_freq_sink_x_0_0, '0']
- [blocks_add_xx_0_0_0, '0', qtgui_time_sink_x_0, '0']
- [blocks_char_to_float_0, '0', qtgui_time_sink_x_2, '0']
- [blocks_char_to_float_0_0, '0', blocks_delay_0, '0']
- [blocks_file_source_0, '0', digital_pfb_clock_sync_xxx_0_0_0, '0']
- [blocks_file_source_0, '0', qtgui_freq_sink_x_0_0_0, '0']
- [blocks_file_source_0, '0', qtgui_time_sink_x_0_0, '0']
- [blocks_file_source_1, '0', digital_constellation_modulator_0_0_0, '0']
- [blocks_file_source_1_0, '0', digital_constellation_modulator_0_0_0, '0']
- [blocks_file_source_3, '0', blocks_throttle2_2, '0']
- [blocks_multiply_const_vxx_0, '0', blocks_throttle2_0_0, '0']
- [blocks_multiply_const_vxx_0, '0', iio_pluto_sink_0_0, '0']
- [blocks_multiply_const_vxx_0, '0', qtgui_freq_sink_x_0, '0']
- [blocks_multiply_const_vxx_0, '0', qtgui_time_sink_x_1, '0']
- [blocks_multiply_const_vxx_0_0_0, '0', blocks_throttle2_0, '0']
- [blocks_multiply_const_vxx_0_0_0, '0', iio_pluto_sink_0_0_0, '0']
- [blocks_multiply_const_vxx_0_0_0, '0', qtgui_time_sink_x_0_1, '0']
- [blocks_pack_k_bits_bb_0_0, '0', blocks_file_sink_0, '0']
- [blocks_phase_shift_0, '0', blocks_add_xx_0_0, '0']
- [blocks_phase_shift_0_0, '0', blocks_add_xx_0_0_0, '0']
- [blocks_repack_bits_bb_0_0, '0', pdu_tagged_stream_to_pdu_0_0, '0']
- [blocks_throttle2_0, '0', blocks_phase_shift_0, '0']
- [blocks_throttle2_0_0, '0', blocks_phase_shift_0_0, '0']
- [blocks_throttle2_2, '0', epy_block_0, '0']
- [blocks_unpack_k_bits_bb_0_0_0_1_0, '0', blocks_char_to_float_0_0, '0']
- [blocks_vector_source_x_0, '0', digital_constellation_modulator_0, '0']
- [blocks_vector_source_x_1, '0', pdu_tagged_stream_to_pdu_0, '0']
- [digital_constellation_decoder_cb_0, '0', blocks_char_to_float_0, '0']
- [digital_constellation_modulator_0, '0', blocks_multiply_const_vxx_0, '0']
- [digital_constellation_modulator_0_0_0, '0', blocks_multiply_const_vxx_0_0_0, '0']
- [digital_constellation_soft_decoder_cf_0_0, '0', satellites_ccsds_concatenated_deframer_1_0,
  '0']
- [digital_costas_loop_cc_0, '0', digital_constellation_decoder_cb_0, '0']
- [digital_costas_loop_cc_0, '0', qtgui_const_sink_x_0_0, '0']
- [digital_costas_loop_cc_0_0_0, '0', digital_constellation_soft_decoder_cf_0_0, '0']
- [digital_pfb_clock_sync_xxx_0, '0', digital_costas_loop_cc_0, '0']
- [digital_pfb_clock_sync_xxx_0_0_0, '0', digital_costas_loop_cc_0_0_0, '0']
- [epy_block_0, '0', pdu_tagged_stream_to_pdu_1, '0']
- [epy_block_0_0, msg_out, epy_block_3, msg_in]
- [epy_block_1_0, msg_out, pdu_pdu_to_tagged_stream_0_1, pdus]
- [epy_block_2, msg_out, epy_block_5_0, msg_in]
- [epy_block_2_1, msg_out, pdu_pdu_to_tagged_stream_0_0_1, pdus]
- [epy_block_3, msg_out, epy_block_2, msg_in]
- [epy_block_4_0, data_out, epy_block_0_0, msg_in]
- [epy_block_4_0, data_out, satellites_hexdump_sink_0_0, in]
- [epy_block_4_0, direct_clcw_out, pdu_pdu_to_tagged_stream_0_0, pdus]
- [epy_block_4_0, response_out, network_socket_pdu_0_0, pdus]
- [epy_block_5_0, msg_out, pdu_pdu_to_tagged_stream_0_0, pdus]
- [epy_block_5_0, msg_out, satellites_hexdump_sink_0, in]
- [iio_pluto_source_0, '0', digital_pfb_clock_sync_xxx_0, '0']
- [iio_pluto_source_0, '0', qtgui_freq_sink_x_0_0, '0']
- [iio_pluto_source_0, '0', qtgui_time_sink_x_0, '0']
- [iio_pluto_source_0_1, '0', blocks_file_sink_2, '0']
- [iio_pluto_source_0_1, '0', digital_pfb_clock_sync_xxx_0_0_0, '0']
- [iio_pluto_source_0_1, '0', qtgui_freq_sink_x_0_0_0, '0']
- [iio_pluto_source_0_1, '0', qtgui_time_sink_x_0_0, '0']
- [network_socket_pdu_0_0, pdus, epy_block_4_0, tcp_in]
- [network_socket_pdu_0_3, pdus, epy_block_4_0, clcw_in]
- [pdu_pdu_to_tagged_stream_0_0, '0', digital_constellation_modulator_0, '0']
- [pdu_pdu_to_tagged_stream_0_0_1, '0', blocks_pack_k_bits_bb_0_0, '0']
- [pdu_pdu_to_tagged_stream_0_1, '0', blocks_repack_bits_bb_0_0, '0']
- [pdu_tagged_stream_to_pdu_0_0, pdus, satellites_convolutional_encoder_1_0, in]
- [pdu_tagged_stream_to_pdu_1, pdus, satellites_encode_rs_ccsds_0_0, in]
- [satellites_ccsds_concatenated_deframer_1_0, out, network_socket_pdu_0, pdus]
- [satellites_ccsds_concatenated_deframer_1_0, out, satellites_hexdump_sink_1, in]
- [satellites_convolutional_encoder_1_0, out, epy_block_2_1, msg_in]
- [satellites_encode_rs_ccsds_0_0, out, epy_block_1_0, msg_in]

metadata:
  file_format: 1
  grc_version: 3.10.10.0
